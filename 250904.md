# useContext 관련 디자인패턴

# 발행-구독(Pub-Sub) 패턴

- 핵심: 발행자와 구독자는 서로 알필요가 없다.
- 브로커만 바라보고 있으면 된다.
- 결합도가 낮아져서 좋다.
- Redux 같은 전역 상태 관리에서 action → store → 구독된 컴포넌트로 전달되는 구조
- Provider가 발행자 역할을하고, Consumer(호출하는 애)가 마치 구독자 처럼 동작
- React 내부 Context 시스템이 브로커의 역할을 한다.

1. 감싼 Provicer에서 value를 발행한고
2. 내부 적으로 바뀌었다는 신호를 Context 에서 관리
3. 받는 사람이 useContext로 구독해서 처리

# 옵저버 패턴

- 중개자가 없다.
- Subject의 상태가 바뀌면 notify로 모든 옵저버들에게 알려준다.

`useContext`는 **옵저버 패턴** 기반.

- Provider가 Subject, Context를 구독하는 컴포넌트들이 Observer 역할.
- Provider 값이 변하면 구독자들이 자동으로 리렌더링됨.

# useContext의 내부 동작

- Fiber 트리를 Event Bus처럼 사용함.

1. Provider의 value를 변경하면, React는 Provider Fiber의 값을 새 값으로 교체
2. Fiber트리에서 해당 영역을 순회하면서 Consumer들을 체크한다.
3. 이전 값과 새로운 값을 비교해서 업데이트 플래그를 추가
   (Pub sub 느낌)
4. 업데이트 플래그가 있는 애들 리렌더링

- **옵저버 패턴 관점**: Provider(Subject)가 직접 Consumer(Observer)에게 알려준다.
- **pub-sub 관점**: Provider가 "값이 바뀌었다"는 이벤트를 발행하면, Context 시스템(중개자)이 모든 구독자에게 알린다.

---

> Fiber란? → 리액트 렌더링 과정을 관리하기 위해 만든 객체 (리액트 작업 단위) (어떤 타입인지, 해당 컴포넌트의 props&state, DOM 정보, 부모형제자식에 대한 포인터, 업데이트 플래그

→ 즉 컴포넌트 하나당의 메타데이터와 작업 상태가 들어가 있음.

→ 이러한 Fiber들의 구조를 연결한 것이 Fiber Tree임.

리액트는 항상 두개의 트리를 가지고 있음

- **Current Fiber Tree** → 현재 화면에 렌더링된 상태
- **WorkInProgress Fiber Tree** → 새로운 업데이트를 반영하려고 계산 중인 상태

→ 교체하면서 진행

- 원래 리엑트는 렌더링이 동기적이었는데, 한번에 큰 트리를 처리하니까 메인 스레드 막혀서 버벅거림
- FIber의 메타 데이터들을 이용하여, 우선순위 작업, 스케줄링

---

- 많은 상태관리 라이브러리들이 사실 useContext와 useReducer를 추상화한 것 이다.

### useReducer?

useState 복잡해진 버전.

```jsx
const [state, dispatch] = useReducer(reducer, initialState);

// 현재 상태
// 상태 변경을 요청하는 함수
// 상태를 변경하는 함수
// 초기값
```

- 여러 액션을 switch case로 분해해서 하기 용이함.- 리액트 포탈을 사용하면, 원래는 컴포넌트가 계층적으로 렌더링 되는데, 특정 부분만 렌더링할 수 있다.
- 스타일 적으로 부모 컴포넌트에 영향을 안받으므로 단독적으로 쉽게 설정할 수 있다.

```jsx

<div>
  <SomeComponent />
  {createPortal(children, domNode, key?)}
</div>

// 리액트 웹 방식
```

- 물리적으로는 위치가 분리되지만, 논리적으로는 종속됨
- 즉 논리적으로는 여기에 있어야하지만, 뷰 상에는 다른곳에 나와야하는 경우 (모달, 토스트, 툴팁, 로딩 인디케이터) 혹은 글로벌하게 배치해야할 경우.
- RN에서는 Portal 구현방식이 조금 다르다.
- 앱 루트에 `<Portal.Host>` 로 감싸서 배치한다.
- 그리고 하위에서 Portal을 실행하면 Portal Host를 찾아서 렌더링 해준다.
  마치 특정 DOM노드로 포탈타고 순간이동 하듯.
  → react-native-paper 라는 라이브러리를 사용.
- Portal로 DOM 트리 밖에 렌더링해도, 이벤트 버블링은 여전히 React 컴포넌트 트리를 따라 올라갑니다.
- 이벤트 버블링? : 자식의 이벤트가 부모에게 전파

- 비동기 API 함수 호출들을 관리할 때 많이 사용함.
- 자동으로 데이터 캐싱, 로딩, 리페치등을 해줘서 코드가 가독성이 좋아짐

두가지 선택지가 있음.

1. **TanStack Query(구 React Query)**
2. **Apollo Client**(GraphQL)

# TanStack Query

```jsx
const { data, isLoading, error } = useQuery({
  queryKey: ["todos"], // 캐싱 키
  queryFn: fetchTodos, // 실제 호출 함수
});
```

- 같은키로 설정하면 서로 캐시를 공유하기 위함

# Apollo useQuery

```jsx
const { data, loading, error } = useQuery(GET_USER, {
  variables: { id },
});
```

- 이것도 페칭할 함수랑 파라미터를 전달받아서 가독성을 높여준다.
- data, loading, error

```jsx
function Users() {
  const [data, setData] = useState<User[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    setLoading(true);
    fetch("/api/users")
      .then((res) => res.json())
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error!</p>;

  return <ul>{data.map((u) => <li key={u.id}>{u.name}</li>)}</ul>;
}

```

```jsx
import { useQuery } from "@tanstack/react-query";

function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ["users"],
    queryFn: () => fetch("/api/users").then((res) => res.json()),
  });

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error!</p>;

  return (
    <ul>
      {data.map((u: any) => (
        <li key={u.id}>{u.name}</li>
      ))}
    </ul>
  );
}
```

- 총평을 하자면 비동기 함수 호출에 있어서 상태를 개발자들이 일일이 정의해야했던 불편을 해소한 것 같다. 관리하기에 가독성 좋아짐!
