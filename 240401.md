# 1. final 키워드를 왜 사용할까요? 성능적 이점에는 무엇이 있을까요?

## 결론: 1. 해당 Class의 상속이 필요없음을 알려줌 →  2. 런타임 성능 향상.

```swift
final class A {
  ...
}
```

## 장점 1
잘못 사용할 때 에러로 알려줌

- 어떤 Class를 상속을 주고 싶지 않을 때 final을 쓴다고 했는데요.
- final을 썻음에도 불구하고, 상속이나 오버라이딩을 해줬다?
- 그러면 에러로 친절하게 알려줍니다.

## 장점 2

## 성능적으로 좋다!

- 증거
    
    ![스크린샷 2024-04-01 오후 12.15.09.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2a65dd92-1694-460a-a843-42f41adf38d8/a5c103b5-eee2-43d2-8d1a-40fbe418bbfe/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.15.09.png)
    
    ![스크린샷 2024-04-01 오후 12.15.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2a65dd92-1694-460a-a843-42f41adf38d8/d88f393b-84c5-428a-bdbd-92048af92768/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_12.15.20.png)
    

## Struct, Class

### Struct (구조체)

→ 값 타입 (Value Type)

→ 복사

→ Stack 영역에 할당

→  **Static Dispatch** 

### Class

→ 참조 타입 (Reference Type)

→ 메모리 주소에 저장

→ heap 영역에 할당

→ **Dynamic Dispatch**

→ 상속이라는 특징

이러한 과정이 런타임 때 이루어지며 이는 당연히 성능 측면에서 불리할 수 밖에 없습니다

• Dispatch란 이때 어떤 함수를 호출할지 결정하는 것을 의미한다.

✔︎ **Static Dispatch (Direct Call)**

컴파일 타임에 실제 호출할 함수를 결정하는 방식으로, 함수 호출이 간단하고 속도가 빠릅니다. Value type 인 구조체와 열거형을 기본적으로 오버라이딩되지 않으므로 Static Dispatch 를 이용합니다.

**✔︎ Dynamic Dispatch (Indirect Call)**

런타임에 호출될 함수를 결정하는 방식으로, 함수 호출 과정에서 실제 참조할 요소를 찾는 과정이 있어 Static 에 비해 속도가 느립니다. 클래스마다 함수 포인터들의 배열인 vtable(Virtual Dispatch Table) 을 갖고 있으며, 이를 참조해 실제 호출할 함수를 결정합니다.

**런타임 시점에 vTable이란 것을 통해 찾아야 해 오버헤드(overhead)가 발생**한다고 했음!

그래서, 결론
final 키워드 마치,
Static Dispatch 처럼 행동하게 해

→ 그래서 빠르다. 좋다.

# vTable이란?

Swift는 클래스마다 vTable을 가지고 있는데 클래스 내부의 함수들 중 어떠한 함수를 호출해야 할지 결정하는 테이블을 이야기 합니다.

즉 함수가 호출되면 vTable에서 지금 class가 어떠한 함수를 호출해야 하는지 조회를 하고 해당 함수를 호출하는 방식인거죠!

왜냐하면 함수가 오버라이딩 될 수 있는 가능성이 있기 때문에 상속받은 함수를 호출해야 할지, 오버라이딩 한 함수를 호출해야 할지 누군가는 알려주어야 하니까요!

# 2. 접근제어자가 무엇인지 설명하고, 왜 사용해야 될까요?

**private**(Type) > **fileprivate**(.swift) > **internal**(모듈 내부) > **public**(모듈 외부에서 상속 및 오버라이딩 불가능) > **open**(모듈 외부에서 상속 및 오버라이딩 가능)

'모듈(module)'이란?

- 하나의 코드 배포 단위이다.
- 프레임워크, 라이브러리, 어플리케이션이 모두 모듈 단위가 될 수 있다.
- 프레임워크와 같이 다른 모듈에서 가져다 쓸 때 import 키워드를 쓴다.
- 반대로 이야기해보면 import 키워드로 추가되는 것은 모두 module이라고 할 수 있다. ex) UIKit, Foundation 등 모두 module이다.

### Open

가장 넓은 범위이다. 지정된 요소는 어디서든 사용 가능하다. `Public` 과 비슷하지만 약간의 차이가 있다.

- `Open`**은 클래스에만 사용 가능하다.**
- `Open`에서만 클래스가 정의된 모듈 외부에서도 `subclassing`할 수 있다.
- `Open`에서만 클래스가 정의된 모듈 외부에서 `override` 할 수 있다.

### Public

스위프트 표준 라이브러리에 있는 기본 요소는 모두 `Open` 래밸을 가진 Struct이다. ex)Bool, Int, String.....

- **클래스가 정의된 모듈 내**에서만 `subclassing`할 수 있다.
- **클래스가 정의된 모듈 내**에서만 `override` 할 수 있다.

### internal

- internal은 기본 접근제어이다.
- 따라서 접근제어 키워드를 아무것도 안 쓰면 internal이 적용된다.
- 선언된 모듈의 내부에서만 '접근', '상속', '재정의' 가능하다.
- 요소 앞에 키워드를 쓰지 않아도 자동으로 지정되는 기본값이다.
- `Internal` 래밸을 가진 요소는 모듈 내부에서는 어디서든 사용 가능하다.

### FilePriavte

- 해당 소스파일 내부에서만 사용 가능하다. (모듈이 같아도 다른 소스파일에서는 사용불가)

### private

- 가장 한정적인 범위이다. 해당 요소를 정의한 범위 내에서만 사용가능하다.
- 클래스 내부에 선언된 private 요소는 같은 파일이더라도 사용 불가능하다.

**(1)**

당연히 하위로 내려갈수록 상위 요소보다 더 높은 접근 수준을 가지면 안 되겠다.

예를 들어, 어떤 클래스는 private 타입인데, 그 클래스 안에 있는 프로퍼티나 메서드가 public이면 안된다는 뜻이다.

**(2)**

또한, 함수의 경우에는 해당 함수의 파라미터 타입이나 리턴 값 타입보다 더 높은 접근 수준을 가져도 안된다.

만약 그렇게 되는 경우에는, 함수 자체에는 접근이 가능해도 실제로 사용할 때 이용할 수 없게 될 것이니.

**(3)**

앞에서 말했지만, 아무런 접근 레벨을 명시하지 않을 경우에는 internal 수준이 default로 설정된다.

![스크린샷 2024-04-01 오후 1.15.16.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/2a65dd92-1694-460a-a843-42f41adf38d8/e82769d5-6093-45b5-8942-b80cf580825d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-04-01_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.15.16.png)

# 3. lazy var, let으로 프로퍼티를 선언하였는데 둘의 차이점은 무엇일까요?

`Lazy` 는 변수의 값이 필요할 때까지 초기화하지 않고 실제로 사용될 때 초기화하도록 하는 프로그래밍 기법입니다.

`Lazy` 키워드를 사용하여 우리가 얻을 수 있는 것은 메모리를 효율적으로 사용할 수 있고, 순환 참조를 방지 할 수 있고, 더욱 안전한 코딩을 가능하게 한다는 점입니다.

1.  lazy property와 관련된 클로저는 오직 그 프로퍼티를 읽을 때만 실행됩니다. 따라서 사용자의 판단에 그 프로퍼티가 잘 사용되지 않는다면, 사용자는 불필요한 할당과 실행을 방지할 수 있습니다.

2. lazy propery를 stored property의 값으로 채울 수 있습니다.

3. **lazy 프로퍼티의 클로저 안에 self를 사용할 수 있습니다.** 이는 순환 참조를 일으키지 않습니다. lazy 변수의 초기화에 사용되는 클로저에는 @noescape가 자동적으로 적용됩니다. 따라서 외부에서 접근하는것이 아니므로 캡쳐를 할 필요가 없습니다.

### **lazy rules:**

- 사용자는 let과 함께 lazy를 사용할 수 없습니다.
→ lazy 자체가 애초에 사용될때만 변하여 값이 초기화 되기 때문에
let 이라는 정적인 요소와 같이 사용할 수 없어요!
- computed property와 사용할 수 없습니다. 왜냐면 computed property는 computation 블록 안의 코드가 모두 실행되고난 다음에 값을 반환하기 때문입니다.
- lazy를 오직 struct나 class의 멤버로만 사용할 수 있습니다.
- lazy 변수는 자동으로 초기화되지 않기 때문에 thread safe 하지 않습니다.
- lazy 변수는 처음 request될 때 초기화되고 그 다음엔 그 값을 계속 저장합니다. 따라서 처음 값을 계속 유지합니다!

# 4.  생명주기는 정말 중요합니다! 다시 한번 꼭꼭 정리해주세요!

viewDidLoad↓
viewWillAppear↓
viewDidAppear↓

viewWillDisappear↓

viewDidDisappear