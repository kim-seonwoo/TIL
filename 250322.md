```python
##### ë„¤ì´ë²„ ì½”ë”©í…ŒìŠ¤íŠ¸ ì¹˜íŒ… ì‹œíŠ¸ #####

# 1. ê¸°ë³¸ ì…ì¶œë ¥ ì²˜ë¦¬
import sys
input = sys.stdin.read

def fast_input():
    return sys.stdin.readline().strip()

def fast_int_list():
    return list(map(int, sys.stdin.readline().split()))

def fast_str_list():
    return sys.stdin.readline().split()

# 2. ì •ë ¬ (ê¸°ë³¸, ë‚´ë¦¼ì°¨ìˆœ, ì»¤ìŠ¤í…€)
def sort_examples():
    arr = [3, 1, 4, 1, 5, 9]
    print(sorted(arr))  # ê¸°ë³¸ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    print(sorted(arr, reverse=True))  # ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    print(sorted(arr, key=lambda x: -x))  # íŠ¹ì • í‚¤ ê¸°ì¤€ ì •ë ¬

# 3. ì´ì§„ íƒìƒ‰ (Binary Search)
import bisect

def binary_search(arr, x):
    idx = bisect.bisect_left(arr, x)  # xê°€ ë“¤ì–´ê°ˆ ìœ„ì¹˜
    if idx < len(arr) and arr[idx] == x:
        return idx  # ì°¾ìŒ
    return -1  # ì—†ìŒ

# 4. BFS / DFS (Graph íƒìƒ‰)
from collections import deque

def bfs(graph, start):
    queue = deque([start])
    visited = set([start])
    while queue:
        v = queue.popleft()
        print(v, end=' ')
        for neighbor in graph[v]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

def dfs(graph, start, visited=set()):
    if start not in visited:
        visited.add(start)
        print(start, end=' ')
        for neighbor in graph[start]:
            dfs(graph, neighbor, visited)

# 5. ë‹¤ìµìŠ¤íŠ¸ë¼ ìµœë‹¨ ê²½ë¡œ ì•Œê³ ë¦¬ì¦˜
import heapq

def dijkstra(graph, start):
    INF = float('inf')
    distances = {node: INF for node in graph}
    distances[start] = 0
    queue = [(0, start)]

    while queue:
        current_distance, current_node = heapq.heappop(queue)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node]:
            distance = current_distance + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(queue, (distance, neighbor))
    return distances

# 6. ë™ì  ê³„íšë²• (DP) - í”¼ë³´ë‚˜ì¹˜ ë©”ëª¨ì´ì œì´ì…˜
from functools import lru_cache

@lru_cache(None)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# 7. ì¡°í•©ê³¼ ìˆœì—´
from itertools import permutations, combinations

def comb_perm_example():
    arr = [1, 2, 3]
    print(list(permutations(arr, 2)))  # ìˆœì—´ (ê¸¸ì´ 2)
    print(list(combinations(arr, 2)))  # ì¡°í•© (ê¸¸ì´ 2)

# 8. í•´ì‹œ (ë”•ì…”ë„ˆë¦¬)
def hash_example():
    hash_map = {}
    hash_map['apple'] = 3
    hash_map['banana'] = 5
    print(hash_map.get('apple', 0))  # ê¸°ë³¸ê°’ ì„¤ì • ê°€ëŠ¥
    print(hash_map.keys(), hash_map.values())

# 9. ëˆ„ì í•© (Prefix Sum)
def prefix_sum(arr):
    prefix = [0] * (len(arr) + 1)
    for i in range(len(arr)):
        prefix[i + 1] = prefix[i] + arr[i]
    return prefix

# 10. íˆ¬ í¬ì¸í„° (Two Pointer) - ë¶€ë¶„í•© ì°¾ê¸°

def two_pointer(arr, target):
    left, right, total = 0, 0, 0
    while right < len(arr):
        total += arr[right]
        right += 1
        while total > target:
            total -= arr[left]
            left += 1
        if total == target:
            return arr[left:right]
    return []

# 11. íŠ¸ë¦¬ DP (Tree Dynamic Programming)
def tree_dp(graph, root, dp, visited):
    visited[root] = True
    dp[root] = 1
    for child in graph[root]:
        if not visited[child]:
            tree_dp(graph, child, dp, visited)
            dp[root] += dp[child]
    return dp

# 12. íŠ¸ë¼ì´ (Trie) ìë£Œêµ¬ì¡°
class TrieNode:
    def __init__(self):
        self.children = {}
        self.is_end = False

class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                node.children[char] = TrieNode()
            node = node.children[char]
        node.is_end = True

    def search(self, word):
        node = self.root
        for char in word:
            if char not in node.children:
                return False
            node = node.children[char]
        return node.is_end

# 13. Union-Find (Disjoint Set)
def find(parent, x):
    if parent[x] != x:
        parent[x] = find(parent, parent[x])
    return parent[x]

def union(parent, rank, x, y):
    rootX, rootY = find(parent, x), find(parent, y)
    if rootX != rootY:
        if rank[rootX] > rank[rootY]:
            parent[rootY] = rootX
        elif rank[rootX] < rank[rootY]:
            parent[rootX] = rootY
        else:
            parent[rootY] = rootX
            rank[rootX] += 1

# 14. ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ (Kruskal Algorithm)
def kruskal(edges, n):
    parent = list(range(n))
    rank = [0] * n
    edges.sort(key=lambda x: x[2])
    mst_weight = 0
    for u, v, weight in edges:
        if find(parent, u) != find(parent, v):
            union(parent, rank, u, v)
            mst_weight += weight
    return mst_weight

```

ë„¤ì´ë²„ ì½”ë”©í…ŒìŠ¤íŠ¸ì—ì„œ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ì•Œê³ ë¦¬ì¦˜ê³¼ ìë£Œêµ¬ì¡° ì£¼ì œë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‹¤ì „ì—ì„œ ë°”ë¡œ ì°¸ê³ í•  ìˆ˜ ìˆëŠ” **ì¹˜íŒ… ì‹œíŠ¸(cheat sheet)** ë¥¼ ì •ë¦¬í•´ì¤„ê²Œìš”. íŠ¹íˆ **ì‹œê°„ ë³µì¡ë„**, **ìì£¼ ì“°ëŠ” ì•Œê³ ë¦¬ì¦˜ íŒ¨í„´**, **ìë£Œêµ¬ì¡°**, **Python ì½”ë“œ ì˜ˆì œ** ì¤‘ì‹¬ìœ¼ë¡œ êµ¬ì„±í–ˆì–´ìš”. Swiftë‚˜ ë‹¤ë¥¸ ì–¸ì–´ê°€ í•„ìš”í•˜ë©´ ë§í•´ì¤˜!

---

## âœ… ê¸°ë³¸ ì•Œê³ ë¦¬ì¦˜ ì‹œê°„ ë³µì¡ë„ ì°¸ê³ 

| ì•Œê³ ë¦¬ì¦˜       | ì‹œê°„ ë³µì¡ë„        | ì„¤ëª…                                   |
| -------------- | ------------------ | -------------------------------------- |
| ì •ë ¬ (Timsort) | `O(N log N)`       | íŒŒì´ì¬ ê¸°ë³¸ ì •ë ¬ (`sort()`/`sorted()`) |
| ì´ì§„ íƒìƒ‰      | `O(log N)`         | ì •ë ¬ëœ ë°°ì—´ì—ì„œ íƒìƒ‰                   |
| ìˆœì—´ / ì¡°í•©    | `O(N!)` / `O(2^N)` | ì™„ì „ íƒìƒ‰, ì‘ì€ Nì¼ ë•Œë§Œ ì‚¬ìš©          |
| BFS/DFS        | `O(V + E)`         | ê·¸ë˜í”„ íƒìƒ‰                            |
| ë‹¤ìµìŠ¤íŠ¸ë¼     | `O(E log V)`       | ìš°ì„ ìˆœìœ„ í ì‚¬ìš©                       |
| ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ  | `O(Î±(N))`          | ê±°ì˜ ìƒìˆ˜ ì‹œê°„                         |

---

## ğŸ“š ìì£¼ ë‚˜ì˜¤ëŠ” ì£¼ì œë³„ ì¹˜íŒ… ì‹œíŠ¸

### ğŸ”¢ 1. ì •ë ¬ & ì´ì§„ íƒìƒ‰

```python
# ì •ë ¬
arr.sort()                 # ì˜¤ë¦„ì°¨ìˆœ
arr.sort(reverse=True)     # ë‚´ë¦¼ì°¨ìˆœ

# ì´ì§„ íƒìƒ‰
import bisect

idx = bisect.bisect_left(arr, target)  # target ì´ìƒ ì²˜ìŒ ìœ„ì¹˜
idx = bisect.bisect_right(arr, target) # target ì´ˆê³¼ ì²˜ìŒ ìœ„ì¹˜

```

---

### ğŸ” 2. ì™„ì „ íƒìƒ‰ (ë°±íŠ¸ë˜í‚¹ í¬í•¨)

```python
from itertools import permutations, combinations

list(permutations(arr, r))   # ìˆœì—´
list(combinations(arr, r))   # ì¡°í•©

# ë°±íŠ¸ë˜í‚¹ ì˜ˆì‹œ
def backtrack(path):
    if len(path) == n:
        result.append(path[:])
        return
    for i in range(n):
        if not visited[i]:
            visited[i] = True
            path.append(arr[i])
            backtrack(path)
            path.pop()
            visited[i] = False

```

---

### ğŸ§­ 3. DFS / BFS

```python
# DFS (ì¬ê·€)
def dfs(v):
    visited[v] = True
    for u in graph[v]:
        if not visited[u]:
            dfs(u)

# BFS
from collections import deque
def bfs(start):
    queue = deque([start])
    visited[start] = True
    while queue:
        v = queue.popleft()
        for u in graph[v]:
            if not visited[u]:
                visited[u] = True
                queue.append(u)

```

---

### ğŸ§® 4. ë‹¤ìµìŠ¤íŠ¸ë¼ (ìš°ì„ ìˆœìœ„ í)

```python
import heapq

def dijkstra(start):
    dist = [float('inf')] * (n + 1)
    dist[start] = 0
    heap = [(0, start)]

    while heap:
        d, u = heapq.heappop(heap)
        if d > dist[u]: continue
        for v, w in graph[u]:
            if dist[v] > d + w:
                dist[v] = d + w
                heapq.heappush(heap, (dist[v], v))

```

---

### ğŸŒ² 5. ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ (Disjoint Set)

```python
def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
    return parent[x]

def union(a, b):
    a, b = find(a), find(b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

```

---

### ğŸ§© 6. ìŠ¬ë¼ì´ë”© ìœˆë„ìš° / íˆ¬ í¬ì¸í„°

```python
# íˆ¬ í¬ì¸í„°
left = right = 0
while right < len(arr):
    # ì¡°ê±´ì— ë”°ë¼ ìœˆë„ìš° í™•ì¥ or ì¶•ì†Œ
    if ì¡°ê±´:
        right += 1
    else:
        left += 1

```

---

### ğŸ“ 7. ëˆ„ì í•© / Prefix Sum

```python
prefix = [0] * (len(arr)+1)
for i in range(len(arr)):
    prefix[i+1] = prefix[i] + arr[i]

# êµ¬ê°„í•© êµ¬í•˜ê¸°
sum_i_to_j = prefix[j+1] - prefix[i]

```

---

### ğŸ“¦ 8. ìë£Œêµ¬ì¡° ë©”ëª¨

```python
from collections import deque, defaultdict, Counter

deque()           # í, ì–‘ë°©í–¥ í
defaultdict(int)  # ê¸°ë³¸ê°’ ë”•ì…”ë„ˆë¦¬
Counter(arr)      # ë¹ˆë„ìˆ˜ ì¹´ìš´í„°

set()             # ì§‘í•© (ì¤‘ë³µ ì œê±°, êµì§‘í•©/í•©ì§‘í•© ë“±)
heapq             # ìµœì†Œ í™ (ìµœëŒ€ í™ì€ -ê°’ ì‚¬ìš©)

```

---

## ğŸ§  ë„¤ì´ë²„ ì½”í…Œ ì¶œì œ ê²½í–¥ ì˜ˆì¸¡

- **ë¬¸ìì—´ ì²˜ë¦¬**: ì •ê·œí‘œí˜„ì‹, ë¬¸ìì—´ ì¡°ì‘
- **ê·¸ë˜í”„ íƒìƒ‰**: DFS, BFS, ë‹¤ìµìŠ¤íŠ¸ë¼
- **ì™„ì „ íƒìƒ‰/ë°±íŠ¸ë˜í‚¹**: í¼ì¦ë¥˜, ì¡°í•© ë¬¸ì œ
- **ìš°ì„ ìˆœìœ„ í**: ì‘ì—… ì²˜ë¦¬ ìˆœì„œ, ë‹¤ìµìŠ¤íŠ¸ë¼
- **í•´ì‹œ/ë”•ì…”ë„ˆë¦¬**: ë¹ˆë„ìˆ˜, ì¤‘ë³µ ì²´í¬
- **íˆ¬ í¬ì¸í„°**: êµ¬ê°„í•©, ì •ë ¬ëœ ë°°ì—´ ë‘ ê°œ ë¹„êµ
- **ìŠ¤íƒ/í**: ê´„í˜¸, ìˆœì„œ ì²˜ë¦¬
- **DP**: ê²½ìš°ì˜ ìˆ˜, ìµœëŒ“ê°’, ìµœì†Ÿê°’ ë“± ë©”ëª¨ì´ì œì´ì…˜

---

í•„ìš”í•˜ë‹¤ë©´ **ë¶„ì•¼ë³„ ì—°ìŠµë¬¸ì œ ì¶”ì²œ**ì´ë‚˜ **Swiftìš© ì¹˜íŒ… ì‹œíŠ¸**ë„ ë§Œë“¤ì–´ì¤„ê²Œìš”!

ì›í•œë‹¤ë©´ "ìƒ ì¤‘ í•˜ ë‚œì´ë„ë³„ ë¬¸ì œ ë¦¬ìŠ¤íŠ¸"ë„ ì¤„ ìˆ˜ ìˆì–´ìš”.
