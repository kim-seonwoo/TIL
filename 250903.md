- [ ] 코어 컴포넌트 보기 (Component, Props(Shadow 빼고)

[Core Components and APIs · React Native](https://reactnative-archive-august-2025.netlify.app/docs/0.74/components-and-apis)

- [ ] Hook → 주요 훅 보기 (State, effect, 커스텀 훅)

[Hook의 개요 – React](https://ko.legacy.reactjs.org/docs/hooks-intro.html)

- [ ] 네비게이션 직접 스크린 두개 정도 만들어보고 해보기

[Getting started | React Navigation](https://reactnavigation.org/docs/getting-started)

- [ ] 과제: UI → 보상가기, 바로가기 2개의 cell 피그마 보고 만들기. 화면이 늘어나도 어떻게 간격을 유지하는가?

[](https://www.figma.com/design/6MCQ6nATn7QX16amnOTeow/-Maum--%EB%AF%B8%EC%85%98?node-id=2301-1825&m=dev)

- [ ] useContext 설명.

# Core Component

# Image

```jsx
<Image
  source={{ uri: url }}
  style={{ width: "100%", aspectRatio: 16 / 9 }}
  resizeMode="cover"
/>

// aspectRatio로 비율 유지한 채 width랑 height만 지정 가능
```

- View를 상속하고 있다.
- resizeMode

1. cover (default) → 비율 유지, 컨테이너보다 이미지가 작으면 늘어남, 크면 잘림
2. contain → 비율 유지, 컨테이너에 완전히 다 들어오도록 축소하거나 확대함 (여백)
3. stretch → 비율 무시, 무조건 컨테이너 크기 우선.
4. center → 이미지 원본 크기 그대로 중앙에 표시.

   ![image.png](attachment:7571fd5e-0737-401e-99aa-7b95c66d7934:image.png)

- source → uri로도 지정되고, require(’/’)로도 지원, 배열로도 여러 사이즈 후보 지원 가능

```jsx
<Image
  source={[
    { uri: "logo@1x.png", width: 50, height: 50 },
    { uri: "logo@2x.png", width: 100, height: 100 },
  ]}
/>
```

- src → 네트워크 URL 문자열만 지원
- tintColor → transparent 요소만
- style → 반드시 크기를 지정해야 렌더링 된다.
- onLoad/ onError로 상태 핸들을 할 수도 있음.

# StyleSheet

- 인라인 스타일을 직접쓰는 대신, StyleSheet.create로 모아둠.

1. create
   주어진 객체로 스타일 시트 참조를 만든다.
2. compose

```jsx
static compose(style1: Object, style2: Object): Object | Object[];
```

두 개의 스타일을 합친다. style1의 속성을 덮어쓴다.
style2의 스타일이 재정의되는 개념.

1. flatten
   스타일 객체 배열을 하나로 합친다.
   병합하여 신규 생성 느낌.

# Alert

?생 alert를 쓸 일이 있을까요?

```jsx
static alert (
  title: string,
  message?: string,
  buttons?: AlertButton[],
  options?: AlertOptions,
);

const createTwoButtonAlert = () =>
  Alert.alert('Alert Title', 'My Alert Msg', [
    {
      text: 'Cancel',
      onPress: () => console.log('Cancel Pressed'),
      style: 'cancel',
    },
    {text: 'OK', onPress: () => console.log('OK Pressed')},
  ]);
```

# Animated

![useRef를 사용하여 애니메이션을 조작하라](attachment:3da4ddf9-1121-4b8f-acf5-5fe142f670bf:스크린샷_2025-09-03_오후_1.34.27.png)

useRef를 사용하여 애니메이션을 조작하라

1. Animated.Value 생성
2. 애니메이션 가능한 컴포넌트 스타일 속성에 연결
3. 메서드로 애니메이션 실행

`useNativeDriver: true` 설정 시

브리지를 거치지 않고, UI 스레드에서 직접 실행됨.

```jsx
import React, { useEffect, useRef, type PropsWithChildren } from "react";
import { Animated, Text, View, type ViewStyle } from "react-native";

type FadeInViewProps = PropsWithChildren<{ style: ViewStyle }>;

const FadeInView: React.FC<FadeInViewProps> = (props) => {
  const fadeAnim = useRef(new Animated.Value(0)).current; // Initial value for opacity: 0
  // 컴포넌트가 리렌더링 되어도 같은 객체를 유지하기 위해.
  useEffect(() => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 10000,
      useNativeDriver: true,
      // 0부터 1로 값이 증가 되면서 네이티브 스레드에서 처리됨
    }).start();
  }, [fadeAnim]);

  return (
    <Animated.View // Special animatable View
      style={{
        ...props.style,
        opacity: fadeAnim, // Bind opacity to animated value
      }}
    >
      // Animated View 안에 연결
      {props.children}
      // FadeInView안에 들어오는 자식에 대하여 이제 애니메이션 적용
    </Animated.View>
  );
};

// You can then use your `FadeInView` in place of a `View` in your components:
export default () => {
  return (
    <View
      style={{
        flex: 1,
        alignItems: "center",
        justifyContent: "center",
      }}
    >
      <FadeInView
        style={{
          width: 250,
          height: 50,
          backgroundColor: "powderblue",
        }}
      >
        <Text style={{ fontSize: 28, textAlign: "center", margin: 10 }}>
          Fading in
        </Text>
      </FadeInView>
    </View>
  );
};
```

# Modal

```jsx
        <Modal
          animationType="slide"
          transparent={true}
          visible={modalVisible}
          onRequestClose={() => {
            Alert.alert('Modal has been closed.');
            setModalVisible(!modalVisible);
          }}>
```

- enum(`'none'`, `'slide'`, `'fade'`) 과 같이 모달 등장 형식을 정의할 수 있다.
- visible로 모달의 여부
- onDismiss, onShow와 같이 시점에 대한 function 정의 가능
- transparent 속성으로 투명하게 배경을 할 지 선택할 수 있다.

# StatusBar

![스크린샷 2025-09-03 오후 2.00.23.png](attachment:b0640730-0ca1-4826-a378-71d18495e9ea:스크린샷_2025-09-03_오후_2.00.23.png)

- 안드로이드 iOS 마다 각각 statusBar에 대한 커스텀을 줄 수 있다.
- 전역적으로 보통 한번만 선언해 준다.

# iOS Components → SafeAreaView

- SafeArea에 맞게 안전한 사이즈를 제공해준다. (아이폰 노치 때문에)
- 보통 전역적으로 flex:1을 주어서 선언해준다.

# Layout Props

- FlexBox 기반
- **alignContent**: 여러 줄(Row) 배치 시 교차축 정렬.
  (`flex-start`, `flex-end`, `center`, `stretch`, `space-between`, `space-around`, `space-evenly`)
- **alignItems**: 부모 안에서 자식들의 교차축 정렬. (CSS align-items와 동일, 기본값 `stretch`)
- **alignSelf**: 개별 자식의 교차축 정렬, 부모의 `alignItems`를 덮어씀.
- **justifyContent**: 주축(메인 축) 정렬.
  (`flex-start`, `flex-end`, `center`, `space-between`, `space-around`, `space-evenly`)
- **flexDirection**: 자식 배치 방향. 기본값은 `column` (CSS와 달리 다름).
  (`row`, `row-reverse`, `column`, `column-reverse`)
- **flexWrap**: 자식이 컨테이너를 넘치면 줄 바꿈 여부. (기본값 `nowrap`)
  `alignItems: stretch`와 같이 쓰면 안 됨.
- **flex**:
  - 숫자로 지정 (CSS와 다르게 문자열 아님)
  - `>0` → 비율대로 공간 차지 (ex: flex=2 는 flex=1보다 2배 공간)
  - `0` → width/height만 따름, 유연성 없음
  - `1` → 공간 부족 시 줄어들 수 있음
- **flexGrow**: 남은 공간 분배 비율.
- **flexShrink**: 공간 부족 시 줄어드는 비율.
- **flexBasis**: 기본 크기(메인축 기준).

# Text Style Props

- color: color
- fontFamily: string
- fontSize: number
- fontStyle: normal, italic
- fontWeight: normal, bold, 100단위
- letterSpacing: 자간
- lineHeight: 행간
- textAlign: enum(`'auto'`, `'left'`, `'right'`, `'center'`, `'justify'`)

# Hook을 왜 써야하는가?

1. 컴포넌트로부터 상태 관련 로직을 추상화해서 분리.
   계층과 무관하고 글로벌하게 상태 관련 로직을 재사용.
   Hook을 통해 서로 비슷한 것을 하는 작은 함수의 묶음으로 컴포넌트를 나눈다.
2. Class는 코드의 최소화를 힘들게 만든다(라이프사이클 기타 등등). 핫 리로딩을 깨지게 한다.
   → 함수를 지향하자. → Class 컴포넌트를 없애진 않겠지만, Hook에 많은 관심 부탁.

# Effect Hook

- Side Effects: 컴포넌트 안에서 데이터를 가져오거나, 구독하고 DOM 조작.
- 상태가 바뀔때 무슨 동작을 수행하고 싶다, useEffect를 사용.
- 기본적으로 매 렌더링 이후에 effect함수를 실행.
- 기본적으로 모든 렌더링에서 함수 수행.
- 구독을 끊는 clean-up이 필요할 때도 있다.

```jsx
useEffect(() => {
  document.title = `Count: ${count}`; // 컴포넌트가 렌더링될 때마다 실행

  return () => {
    // 컴포넌트가 언마운트될 때 실행될 정리 작업 (optional)
    // 웹소켓이나 타이머 같은것들 메모리 누수가 발생할 만한 것들 연결해지
  };
}, [count]); // count가 변경될 때마다 effect 실행
// dependency라고 부름

// 1. 배열 안쓰면 매번 렌더링
// 2. 안에 값 적으면 해당 값만 바뀌었을 때
// 3. 빈 배열 최초 1회만 실행
```

# Hook 사용 규칙

1. 최상위에서만 호출해야 한다. 괜히 다른 함수 안에서 호출하지 마라.
2. React 함수 컴포넌트 내에서만 호출해라. 혹은 커스텀 훅.

# 커스텀훅

- 비즈니스 로직을 분리
- store 부분에 대한 비즈니스로직을 추가해서 한번 더 가공하나?

서버 API 호출
↓
Store (전역 상태 저장 / 업데이트)
↓
Hook (스토어 로직 + 비즈니스 로직 + side effect)
↓
Screen (UI에서 hook 사용 → 값 읽어서 렌더링)

### 주요 사용하는 경우

- **API 호출** → 데이터 로딩, 에러 핸들링 분리
- **상태 관리 단순화** → 토글, 모달, 드롭다운, 로딩 등
- **복잡한 비즈니스 로직 캡슐화** → 폼 처리, 무한 스크롤, 캐싱

# State Hook

- `useState`
- 원래 class에서는 그 자체가 상태를 들고 있다. 하지만 훅을 쓰면 함수 안에서 react state를 사용할 수 있게 해준다.
- this.state.count 이런식으로 가져왔어여 했다.
- `return [hook.memoizedState, dispatch]`
  이 부분을 useState에서 구조 할당 분해

# useRef

- 특정 DOM 선택, 명령형 제어나 리렌더링 필요없을때
- 예를들어 값을 화면에 보일 필요없는 계산에도 사용.

# useMemo

- 배열안에 넣은 내용이 바뀌면 함수를 호출해서 연산, 아니면 캐싱해서 값을 줌
- 메모이제이션 자체의 비용이 있기 때문에 무분별하게 사용하면 좋지 않다. 계산할 때 너무 무거워 보인다, 이때만 쓴다.

```jsx
const square_value = useMemo(() => square(number), [number]);
```

# useCallback

- useMemo랑 유사한데 함수 재사용
- 함수 생성에 드는 비용을 줄여준다.

```jsx
const [toggle, setToggle] = useState < boolean > false;

const toggling = useCallback(() => {
  setToggle(!toggle);
}, [toggle]);
```

# 자주쓰이는 패턴

```jsx
npm install @react-navigation/native
npm install react-native-screens react-native-safe-area-context
npm install @react-navigation/native-stack
```

```jsx
cd ios && pod install && cd ..
```

```jsx
type RootStackParamList = {
  Home: undefined;
  Detail: { itemId: number }; // Detail 화면은 파라미터 받음
};

const Stack = createNativeStackNavigator<RootStackParamList>();

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator initialRouteName="Home">
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Detail" component={DetailScreen} />
      </Stack.Navigator>
      // 이 자체를 별도의 스택파일로 분리해서 사용도 많이하는 듯
    </NavigationContainer>
  );
}
```

```jsx
type HomeScreenNavigationProp = NativeStackNavigationProp<RootStackParamList, 'Home'>;

export default function HomeScreen() {
  const navigation = useNavigation<HomeScreenNavigationProp>();

  return (
    <View>
      <Button
        title="Go to Detail"
        onPress={() => navigation.navigate('Detail', { itemId: 42 })}
      />
    </View>
  );
}
```

```jsx
type DetailRouteProp = RouteProp<RootStackParamList, "Detail">;

export default function DetailScreen({ route }: { route: DetailRouteProp }) {
  return <Text>Detail ID: {route.params.itemId}</Text>;
}
```

- Stack: 화면이 쌓이는 구조 (뒤로가기 가능) → 로그인 → 홈 → 상세 화면
- Tab: 하단 탭바 → 홈, 채팅, 프로필
- Drawer: 옆에서 슬라이드로 열리는 메뉴 → 보조 메뉴, 설정 등

```jsx
const Tab = createBottomTabNavigator<RootTabParamList>();

export default function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator screenOptions={{ headerShown: false }}>
        <Tab.Screen name="HomeTab" component={HomeStack} options={{ title: '홈' }} />
        <Tab.Screen name="ProfileTab" component={ProfileScreen} options={{ title: '프로필' }} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}
```

```jsx
navigation.reset({
  index: 0,
  routes: [{ name: "Home" }],
});
```

- reset / replace: 뒤로 가기 스택을 없애고 화면 교체 (ex. 로그인 성공 시 홈으로 이동)

```jsx
navigation.replace("Home");
navigation.goBack();
navigation.setOptions({
  title: "상세보기",
});
```

# 0.72 이후 도입된 API 패턴

- 정적 네비게이션 패턴

```jsx
export type RootStackParamList = {
  Home: undefined,
  Detail: { itemId: number },
};

// 2. 스택 생성
const RootStack =
  createNativeStackNavigator <
  RootStackParamList >
  {
    initialRouteName: "Home",
    screens: {
      Home: HomeScreen,
      Detail: DetailScreen,
    },
  };

// 3. 정적 네비게이션 객체 생성
const Navigation = createStaticNavigation(RootStack);

// 4. 앱 컴포넌트
export default function App() {
  return <Navigation />;
}
```

- 네비게이터 구조가 타입스크립트 수준에서 완전히 고정됨
- 런타임 대신 빌드 타임에 네비게이션 구조가 정해지므로 성능이 좋고 오류 가능성이 줄어듦.
  [useContext – React](https://react.dev/reference/react/useContext)

- **전역 상태 관리**처럼 데이터를 여러 컴포넌트에 공유할 때 쓰는 훅
- Context API를 사용하는 훅

```jsx
export const ThemeContext = (createContext < "light") | ("dark" > "light");
```

```jsx
export default function App() {
  const [theme, setTheme] = (useState < "light") | ("dark" > "light");

  return (
    <ThemeContext.Provider value={theme}>
      <MyComponent />
    </ThemeContext.Provider>
  );
}
```

```jsx
function MyComponent() {
  const theme = useContext(ThemeContext);

  return (
    <View style={{ backgroundColor: theme === "light" ? "white" : "black" }}>
      <Text style={{ color: theme === "light" ? "black" : "white" }}>
        현재 테마: {theme}
      </Text>
    </View>
  );
}
```

- 가볍고 의존성 없는 장점
- 여러 컨텍스트를 만들어야해서 불편하다.
- 프로바이더에 값이 바뀌면 모든 하위 컴포넌트가 리렌더링 (비효울적임..)
- 글로벌 테마, 로그인 여부, 언어 설정 → 단순하면서.. 어차피 다 리렌더링 되어야할 때

## 상태관리 선택지들..

- Zustand → 간단함, 리렌더링 최적화가 내장되어 있음, DevTools 지원이 약함
- Redux Toolkit → 공식 툴킷, 복잡함.
