# 다익스트라

- 가중치가 동일하지 않는데, 최단 거리를 구하려면?
- 거리 배열을 완전 큰 값으로(INF) 초기화하고, 출발지의 값만 0으로 설정.
- 우선순위 큐에서 최솟값 팝하면서, 연관된 노드들 그 거리를 더하여 갱신해줌
- 계속 우선순위큐의 최솟값으 순회하면서 반복하여 거리를 적어줌

# 플로이드 워셜

- 모든 쌍에 대해 최단거리를 구해야하는 상황
- 다익스트라와 유사
- O(V^3)

```python
function floyd(graph)
    set dist = |V| * |V| array initialized to INF  // 처음 dist 배열을 아주 큰 값인 INF로 초기화합니다.
    for each edge(u, v)                            // 주어진 그래프의 모든 간선에 대해
        dist[u][v] = length(u, v)                  // 각 간선의 가중치를 dist 배열에 적어줍니다.
    for k = 1 ... |V|                              // 확실하게 거쳐갈 정점을 1번부터 V번까지 순서대로 정의합니다.
        for i = 1 ... |V|                          // 고정된 k에 대해 모든 쌍 (i, j)를 살펴봅니다.
            for j = 1 ... |V|
                if dist[i][j] > dist[i][k] + dist[k][j]     // i에서 j로 가는 거리가 k를 경유해 가는 것이 더 좋다면
                    dist[i][j] = dist[i][k] + dist[k][j]    // dist[i][j]값을 갱신해줍니다.
    return dist

```

고정된 K에 대한 (i, j)를 또 살펴보면서, 다른 곳 들리는게 최적이면 갱신해준다.

# Kruskal

- MST → 가중치가 있을 때 최소한의 비용을 사용한 Spanning Tree
- Union Find → 그래프에서 서로 연결된 노드를 하나의 집합으로 묶을 때 사용.

📌 **주요 기능**

1. **Find(x)**: `x`가 속한 집합(루트 노드)을 찾음
2. **Union(x, y)**: `x`와 `y`가 속한 두 집합을 합침

경로 압축 → 루트노드라면 값을 반환, 루트 노드가 아니라면 더 탐색 진행에서 → uf[x] 값을 루트 노드로 바꿔준 뒤, 루트 노드를 반환해준다.

- 절대 사이클이 생겨서는 안된다.

```python
function kruskal()
    mst = []                       // mst를 담을 배열입니다.
    sort edge[] by length          // 간선을 가중치 기준으로 오름차순 정렬합니다.
    uf = uf_init(|V|)              // uf 배열을 노드의 수 |V|만큼 초기화합니다.

    for E in edge[]                // 각각의 간선에 대해
        u, v = E                   // 간선을 이루고 있는 두 노드 u, v를 보며
        if find(u) != find(v)      // u, v의 루트 노드가 다른 경우에만
            mst.push(E)            // mst에 해당 간선을 넣어주고
            union(u, v)            // u, v를 같은 루트 노드를 갖도록 만들어줍니다.

    return mst

```

# 프림

- 한 지점에서 시작하여 점점 확장을 진행하는 방법
- prim은 단순히 `dist[v]`와 `length(u, v)`를 비교하여 갱신해주기만 하면 됩니다.

# 위상 정렬

**1번 정점부터 n번 정점까지 순서대로 보면서 아직 방문한 적이 없는 정점에 대해서는 전부 해당 정점을 시작점으로 하여 dfs를 추가적으로 진행해줘야만 한다는 것입니다.**
