기수 정렬(Radix Sort)과 병합 정렬(Merge Sort)은 둘 다 정렬 알고리즘이지만, 서로 다른 원리와 특성을 가지고 있습니다. 아래에서 각각의 정렬 알고리즘에 대해 자세히 설명하겠습니다.

---

### **1. 기수 정렬 (Radix Sort)**

#### **정의**

기수 정렬은 데이터를 자리수별로 정렬하는 **비교 기반이 아닌 정렬 알고리즘**입니다. 주로 숫자와 문자열 정렬에 사용되며, 각 자리의 값을 기준으로 정렬을 반복하여 전체 배열을 정렬합니다.

#### **작동 원리**

1. 가장 낮은 자리수(1의 자리)부터 높은 자리수로 진행하며 각 자리수에 대해 정렬을 수행합니다.
2. 안정 정렬(Stable Sort, 예: 계수 정렬 또는 버킷 정렬)을 사용하여 각 자리수를 기준으로 데이터를 정렬합니다.
3. 모든 자리수에 대해 정렬을 끝내면 최종적으로 정렬된 배열을 얻습니다.

#### **시간 복잡도**

- **최선/평균/최악**: \( O(d \cdot (n + k)) \)
  - \( d \): 숫자의 최대 자릿수
  - \( n \): 입력 배열의 크기
  - \( k \): 각 자리수의 가능한 값의 범위 (예: 0-9는 10)

#### **특징**

- 비교 기반 정렬이 아니기 때문에, 숫자와 문자열 정렬에서 효율적입니다.
- 안정 정렬입니다.
- 메모리를 추가로 사용하므로 공간 복잡도는 높을 수 있습니다.

#### **예제**

배열: `[170, 45, 75, 90, 802, 24, 2, 66]`

1. 1의 자리를 기준으로 정렬: `[170, 90, 802, 2, 24, 45, 75, 66]`
2. 10의 자리를 기준으로 정렬: `[802, 2, 24, 45, 66, 170, 75, 90]`
3. 100의 자리를 기준으로 정렬: `[2, 24, 45, 66, 75, 90, 170, 802]`

---

### **2. 병합 정렬 (Merge Sort)**

#### **정의**

병합 정렬은 **분할 정복(Divide and Conquer)** 기법을 사용하여 데이터를 정렬하는 비교 기반 알고리즘입니다. 배열을 재귀적으로 분할하고, 정렬된 부분 배열을 병합하면서 정렬을 완성합니다.

#### **작동 원리**

1. 배열을 절반으로 분할합니다.
2. 각 부분 배열에 대해 재귀적으로 병합 정렬을 수행합니다.
3. 정렬된 두 부분 배열을 병합하여 하나의 정렬된 배열을 만듭니다.

#### **시간 복잡도**

- **최선/평균/최악**: \( O(n \log n) \)
  - \( n \): 입력 배열의 크기
- **공간 복잡도**: \( O(n) \) (추가 배열을 사용)

#### **특징**

- 안정 정렬입니다.
- 재귀적으로 호출되므로 스택 오버플로우 문제가 발생할 수 있습니다.
- 입력 크기가 클수록 효율적입니다.

#### **예제**

배열: `[38, 27, 43, 3, 9, 82, 10]`

1. 분할: `[38, 27, 43, 3]`, `[9, 82, 10]`
2. 다시 분할: `[38, 27]`, `[43, 3]`, `[9]`, `[82, 10]`
3. 정렬 후 병합: `[27, 38]`, `[3, 43]`, `[9, 10, 82]`
4. 최종 병합: `[3, 9, 10, 27, 38, 43, 82]`

---

### **기수 정렬과 병합 정렬 비교**

| **특성**           | **기수 정렬 (Radix Sort)**    | **병합 정렬 (Merge Sort)** |
| ------------------ | ----------------------------- | -------------------------- |
| **시간 복잡도**    | \( O(d \cdot (n + k)) \)      | \( O(n \log n) \)          |
| **공간 복잡도**    | \( O(n + k) \)                | \( O(n) \)                 |
| **비교 기반 여부** | 아니요                        | 예                         |
| **안정성**         | 안정 정렬                     | 안정 정렬                  |
| **데이터 유형**    | 숫자, 문자열                  | 숫자, 문자열               |
| **특징**           | 빠르지만 자리수와 범위에 의존 | 안정적이며 범용적          |

---

### **언제 어떤 것을 선택할까?**

- **기수 정렬**: 데이터가 숫자 또는 고정 길이의 문자열일 때 사용하며, 특히 데이터 크기가 크고 자릿수가 적을 때 유리합니다.
- **병합 정렬**: 범용적이고 안정적이기 때문에 비교 기반 정렬이 필요하거나 모든 유형의 데이터에서 사용할 수 있습니다.
