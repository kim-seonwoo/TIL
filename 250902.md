# 1. Introduction

![리액트, 안드, 아요 지식 없이 배울수 있게하는게 추구미](attachment:0a434417-c7e9-4cb5-86a3-66a455211cf3:스크린샷_2025-09-02_오전_11.14.23.png)

리액트, 안드, 아요 지식 없이 배울수 있게하는게 추구미

# 2. Core Components and Native Components

`Components: bundles of reusable, nestable code.`

런타임동안 안드로이드랑 iOS 뷰에 해당되는 컴포넌트 생성, 뒷단에서 하는것을 네이티브 컴포넌트라고 한다.

각각 네이티브에 대응되는 RN의 컴포넌트는 코어 컴포넌트라고 한다.

React Native 코어 컴포넌트를 사용하지 않고, 특정 플랫폼이나 위젯에서 직접 Native UI Component를 만들어야하는 경우도 있다.

Android:

- `ViewManager` 작성 (`createViewInstance`, `@ReactProp` 등 구현)
- 패키지에 등록 (`createViewManagers`)
- JS에서 `requireNativeComponent`로 불러오기
- (필요하다면) 이벤트 연결 및 Fragment 연동

iOS 도:
RCTViewManager 서브클래스 생성
JS에서 requireNativeComponent로 연결
콜백 연결

![New 아키텍쳐?](attachment:b1f4e149-1990-4ce9-8775-14b8121d1998:스크린샷_2025-09-02_오전_11.24.31.png)

New 아키텍쳐?

- New 아키텍쳐
  요약 : `JavaScript와 네이티브가 기존의 브릿지 대신 JSI(C++) 를 통해서 양방향으로 직접 소통이 가능해진다. 그것도 동기적으로`
      `Fabric (렌더링)`
      - 산재되지 않고, 공통 로직으로 다양한 플랫폼에서 최적화된 그리기 지원. React Element Tree를 기반으로 뷰의 실행 흐름 최적화.
      - 대부분의 UI 상태변화는 React에서의 상태 변화로부터 이루어지기 때문에, 데이터는 React - RN - Host plaform으로 흐름.
      - 그런데, 스크롤뷰 같은 경우는 Host Platform 단에서만 처리가 됨 (리액트의 상태 변화와는 무관함)
      - 리액트 렌더링 이후의 React Shadow Tree 업데이트에만 관여함 (별도의 C++ 상태값으로 관리)
      - C++ 상태변화는 JS 스레드 UI 스레드 중 하나만 반영이 되도록 설계가 되어있음. thread safetry하게

      [React-Native 8년차가 바라본 New architecture](https://velog.io/@bang9dev/awesome-react-native-new-architecture)

      JSI
      React fiber -> React-Native fabric -> Host UI
      기존에는 JS에서 생긴 변화가 UIManger를 거치고 실제 업데이트 까지 이루어진다. (네이티브 단에서 바로 알 수 있는 변화가 JS 영역에서는 지연)
      브릿지를 사용할때는 비동기적으로 동작하기 때문에 정확한 UI 업데이트 시점을 알아내기 어려움.
      하지만, Fabric에서는 자바스크립트의 변경을 브릿지를 거치지 않고, 동기적으로 전달한다. 이것을 가능하게 하는 것이 JSI 이다.

      ![위와 같이 절차가 상당히 많아지면서, UI 그려지기 전 개입 여지가 많아짐.](attachment:65fc4f1b-4545-4ced-8001-d45851c411c7:스크린샷_2025-09-02_오전_11.49.24.png)

      위와 같이 절차가 상당히 많아지면서, UI 그려지기 전 개입 여지가 많아짐.

      - 동기적으로 처리하기 때문에, 콜백을 할 필요가 없다.

      ### Codegen

      - JS쪽에서 정의도니 타입을 통해 네이티브 모듈에 타입을 생성
      - 즉 개발자 C++ 몰라도 되는거임.
      - 자동 타입 생성

      ### **TurboModules**

      - 기존 Native Module은 Bridge를 통해 JS에서 호출했는데, 이제는 **JSI 기반으로 네이티브 모듈을 직접 호출**.
      - 장점:
          - 필요한 모듈만 **Lazy Load** 가능 → 앱 시작 시 불필요한 모듈 로딩 방지.
          - 동기 함수 호출도 지원 (예: 네이티브 저장소에서 값 읽기).
          - 네이티브 모듈과 JS의 경계가 더 얇아짐.

[Core Components and APIs · React Native](https://reactnative.dev/docs/components-and-apis)

## View

- UIVIew, android.view.View, <div>에 대응
- **Flexbox** 중심: `flex`, `flexDirection`, `justifyContent`, `alignItems`, `gap`, `rowGap/columnGap`
- onLayout으로 위치 크기 조회
- View의 크기를 지정하지 않으면, 자식요소에 따라서 크기가 유동적으로 지정됨

## TouchableOpacity

- 터치에 반응하여 시각적 피드백
- 버튼에 비해서 커스텀 스타일링이 가능

## Pressable

- TouchableOpacity 보다 더 광범위하게 사용자 상호 작용을 처리하도록 설계되었습니다.
- 다양한 터치 상태(pressed, hovered, focused 등)에 대한 세밀한 제어가 가능합니다.
- 성능 최적화 (리액트 네이티브 팀 권장)

![스크린샷 2025-09-02 오후 6.15.41.png](attachment:92451ea8-30da-4e0f-9c67-eda147334272:스크린샷_2025-09-02_오후_6.15.41.png)

## Text

- 인라인으로 처리
- 서브트리 내에서만 스타일이 상속이 됨.
- 단순 링크 텍스트 onPress하기도 함.

# 3. React Fundamentals

- components
- JSX
- props
- state

## Components

- 재사용이 가능한 독립된 모듈
- 일관성이 핵심

## JSX

- HTML-like markup inside a JavaScript file
- 브라우저에서 실행하기 전에 바벨을 사용하여, 일반 자바스크립트 형태의 코드로 변환된다.
- 개발자가 JSX를 작성하기만 하면, 리액트 엔진은 JSX를 기존 자바스크립트로 해석하여 준다. 이를 선언형 화면 기술이라고 한다.
- 확장자로써 .js vs .jsx 요즘 그렇게 중요하지 않다. (관행은 따르자)

## Props

- props는 read-only로 읽기 전용이다.
- 함수가 pure 해야한다. → 파라미터에 영향을 줄 수 없다. 인풋에서 아웃풋 순수한 흐름.

## State

```jsx
const [isHungry, setIsHungry] = useState(true);
```

- useState란 훅을 사용합니다.

```jsx
// useState
useState : function (intitialState){
    currentHookNameInDev = 'useState'; // 변수를 받아와서 초기 상태값을 설정
    mountHookTypesDev(); // 현재 사용중인 hook의 이름을 추적 및 타입 저장
    var prevDispatcher = ReactCurrentDispatcher$1.current; // Dispatcher 을 가리킴, 디버깅에 사용됨
    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;

    try{
        return mountState(initialState); // useState 함수는 실제로 상태를 return 받아 설정됨
    }finally{
        ReactCurrentDispatcher$1.current = prevDispatcher;
    }
}

function mountHookTypesDev(){
    {
        var hookName = currentHookNameInDev;
        if(hookTypesDev === null){ // hook의 값과 타입을 저장
            hookTypesDev = [hookName];
//여기가 핵심임 다음 렌더와 배열을 비교해서 검사함
        }else{
            hookTypesDev.push(hookName)
        }
    }
}

function mountState(initialState){
    var hook = mountWorkInProgressHook(); // mountWorkInProgressHook 함수는 현재 hook 을 가져옴
    if(typeof initialState === "function"){
        initialState = initialState(); // initialState 가 함수이면 초기값 상태로 값을 가져옴
    }

    hook.memoizedState = hook.baseState = initialState;
    var queue = { // queue 객체는 상태 업데이트 큐와 관련된 정보를 가짐
        pending : null,
        interleaved: null,
        lanes : NoLanes,
        dispatch: null,
        lastRenderedReducer : basicStateReducer,
        lastRenderedState : initialState
    };

    // 이처럼 useState는 비동기적인 특징을 갖는다? 매번 렌더링 하지 않으니

    hook.queue = queue;
    var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue); // dispatch함수는 상태를 업데이트 하는 함수
    return [hook.memoizedState, dispatch] // 최종적으로 반환되는 값
}

// 호출되면 업데이트 객체를 큐에 넣고, 우선순위를 설정하고, 스케줄링해서 다음 렌더를 요청.
마운트 시: 훅 리스트에 state 훅 노드를 하나 만들고,
memoizedState = 초기값, queue를 달아준 뒤, setState(dispatch)를 바인딩해 돌려줍니다.

setState 호출 시:
업데이트가 queue.pending(원형 리스트)에 쌓이고, 루트에 스케줄이 걸립니다.

다음 렌더에서:
baseState + 큐의 업데이트들을 차례로 적용해 새 상태(memoizedState)를 만들고,
우리는 그 스냅샷을 다시 받습니다.

```

- Hook은 class에 비해 간결하고, 재사용하기가 쉽다. 내부적으로 해주는게 많다.
- 선언형 UI는 상태를 선언만 해주면 내부적으로 특정상황에 DOM/네이티브 뷰를 어떻게 바꿀지는 알아서 (내부적으로는 절차적으로) 반영.
- useState는 그 상태 변화를 큐(원형 연결 리스트)에 쌓고, 다음 렌더에서 안전하고 일관되게 순서대로, 계산해 실제 UI 차이만 반영하도록 도와준다.
- 새 상태가 이전 상태와 동일하면 리렌더를 유발하지 않고 작업을 건너뜀.
- React는 내부적으로 업데이트에 우선순위(레인)를 부여하고 스케줄링합니다. 긴급한 업데이트는 먼저, 낮은 우선순위는 나중에 처리해 UX를 부드럽게 유지합니다.
- 구독하는 거와는 개념이 좀 다름, setter를 호출하면 다시 그 컴포넌트가 렌더링 되도록 스케줄하는 거 뿐.
- setState할때는 함수의 형식으로 해준다. → 렌더링 타이밍이 다른 문제 때문에.
- **Choosing the State Structure**
  - 연관있는 상태는 함께 묶기 (항상 같이 바뀌는 상태이면, 묶어버리자)
  - 서로 모순 되는 상태들을 만들지 말아라. → 이럴바에 enum으로 처리해라
  - 렌더링 중 계산이 가능한 값은 state에 굳이 두지 않기.
    → a + b 상태로 c가 갱신되는 경우 굳이 c를 state로 둘 이유가?
  - 값이 복사되는 상태를 피해라. 그러면 싱크가 깨져서 곤란하다.
  - 깊이 중첩이 되는 것을 지양해야한다.
  → DB 설계 시 정규화의 개념과 비슷하다.

# 4. Handling Text Input

- 키보드 타입을 강제 할 수는 있다. 어떤 형태의 키보드인지 대문자 활성화인지

```jsx
        <TextInput
          editable
          multiline
          numberOfLines={4}
          maxLength={40}
          onChangeText={text => onChangeText(text)}
          value={value}
          style={styles.textInput}
        />
      <TextInput
      value={formById[item.id] ?? ''}     // 컨트롤드
      onChangeText={(t) => onChange(item.id, t)}
    />

    // 상태를 저장해놔야지 언마운트, 마운트 되어도 유지..
```

### Methods

- **`.focus()`**: 입력에 포커스 요청
- **`.blur()`**: 포커스 해제
- **`clear()`**: 모든 텍스트 삭제
- **`isFocused(): boolean`**: 현재 포커스 여부 반환

이러한 메소드 제어에는 useRef와 함께 많이 사용함.

렌더링 없이 DOM요소에 직접 접근.

## KeyboardAvoidingView

- 키보드가 올라올 때 화면의 입력 UI가 가려지지 않도록 하는 컨테이너
- `behavior`: 레이아웃을 **어떻게** 피할지
  - `'padding'` (iOS 선호): 컨텐츠 하단에 패딩을 늘림
  - `'position'`: 컨테이너의 `top`/`bottom` 위치를 올림
  - `'height'`: 컨테이너 높이를 줄임
- `keyboardVerticalOffset` (number): **추가 여유 오프셋**. 상단 헤더/상태바/세이프에어리어만큼 더 띄우는 값

![Simulator Screen Recording - iPhone 16 Pro - 2025-09-02 at 16.55.57.gif](attachment:451b5e93-bd07-43c5-b140-eff4c10a3170:Simulator_Screen_Recording_-_iPhone_16_Pro_-_2025-09-02_at_16.55.57.gif)

```jsx
      <KeyboardAvoidingView
        style={{ flex: 1 }}
        behavior={Platform.select({ ios: 'padding', android: undefined })}
        keyboardVerticalOffset={offset}
      >
```

**Android**: `AndroidManifest.xml`의 `<activity ... android:windowSoftInputMode="adjustResize">`가 **먼저**.

`onSubmitEditing`으로 **다음 입력으로 포커스 이동**(refs로 관리).

`useState, FlatList, ScrollView`

`Style
View, TochableOpacity`

# 5. Using a ScrollView

- 스크롤 뷰 상위의 부모 요소의 높이가 제한되어있어야 한다.
- 즉 스크롤 뷰보다 작은 제한된 크기여야 유의미하다.
- 즉시 모든 요소를 한번에 렌더링
- 레이아웃/스크롤
  - `horizontal`: 가로 스크롤
  - `contentContainerStyle`: **자식들을 감싸는 콘텐트 영역** 스타일(패딩, `flexGrow: 1` 등)
  - `pagingEnabled` / `decelerationRate="fast"`: 페이지 단위/빠른 감속
  - `snapToInterval` / `snapToOffsets` / `snapToAlignment`: 스냅 포지셔닝
  - `removeClippedSubviews`: 화면 밖 뷰 제거(긴 콘텐츠 성능 개선; 일부 조합 주의)
- 안전영역/인셋(iOS)
  - `contentInset`, `contentInsetAdjustmentBehavior`
  - `automaticallyAdjustContentInsets`(iOS), `automaticallyAdjustsScrollIndicatorInsets`(iOS)
  - `automaticallyAdjustKeyboardInsets`(iOS): **키보드 높이만큼 인셋 자동 보정**
- 키보드 UX
  - `keyboardDismissMode`: `'on-drag'`(iOS는 `'interactive'`도 가능)
  - `keyboardShouldPersistTaps`: `'handled'` / `'always'` (스크롤 안에서 버튼 탭 막히는 문제 해결)
- 인디케이터/바운스
  - `showsVerticalScrollIndicator` / `showsHorizontalScrollIndicator`
  - `indicatorStyle`(iOS), `bounces`/`alwaysBounce*`(iOS), `overScrollMode`(Android)
- 스티키/채팅 보정
  - `stickyHeaderIndices`: 특정 자식을 상단에 고정
  - `StickyHeaderComponent`: 스티키 헤더 커스텀 컴포넌트
  - `maintainVisibleContentPosition={{ minIndexForVisible: 0, autoscrollToTopThreshold: N }}`:
    **채팅형**에서 위에 새 항목 추가해도 “보이던 메시지” 위치 유지

```jsx
<ScrollView
  horizontal
  pagingEnabled
  decelerationRate="fast"
  snapToAlignment="center"
  showsHorizontalScrollIndicator={false}
>
```

# 6. Using List Views

## FlatList

- FlatList: 가변 렌더링으로 효율 상승 (마운트, 언마운트 보이는 부분만)
  특정한 cell 반복
- 고유한 키 값이 반드시 필요함.
- **`horizontal`**: 가로 스크롤.
- **`numColumns`**: 그리드(세로 리스트에서 n열).
- **`columnWrapperStyle`**: `numColumns` 사용 시 각 행 래퍼 스타일.
- **`contentContainerStyle`**: 콘텐츠 컨테이너(패딩, `flexGrow:1` 등).
- **`inverted`**: 채팅처럼 역방향(아래로 쌓이게).
- **`style`**: 리스트 자체 스타일.

```jsx
      <FlatList
        data={[
          {key: 'Devin'},
          {key: 'Dan'},
          {key: 'Dominic'},
          {key: 'Jackson'},
          {key: 'James'},
          {key: 'Joel'},
          {key: 'John'},
          {key: 'Jillian'},
          {key: 'Jimmy'},
          {key: 'Julie'},
        ]}
        renderItem={({item}) => <Text style={styles.item}>{item.key}</Text>}
      /> // 둘은 필수
      keyExtractor={(item) => String(item.id)} -> item.key가 없다면 사용

```

- SectionList: 섹션 별로 헤더 처리가 필요할 경우 → iOS UITableView같은 느낌

```jsx
<SectionList
  sections={[
    { title: "D", data: ["Devin", "Dan", "Dominic"] },
    {
      title: "J",
      data: ["Jackson", "James", "Jillian", "Jimmy", "Joel", "John", "Julie"],
    },
  ]}
  renderItem={({ item }) => <Text style={styles.item}>{item}</Text>}
  renderSectionHeader={({ section }) => (
    <Text style={styles.sectionHeader}>{section.title}</Text>
  )}
  keyExtractor={(item) => `basicListEntry-${item}`}
/>
```

- `네이티브 식 셀 재사용 vs 가상화?`
  - iOS는 “같은 셀 인스턴스를 돌려 쓰는 재사용 풀”. 화면에 보이는 셀 만큼만 만들어서 돌려쓴다.
  - RN은 “보이는 주변만 마운트하는 가상화 + 키로 정체성 유지”.

# 7. 트러블슈팅

```jsx
sudo lsof -i :8081
```

```jsx
kill -9 <PID>
```

8081번 포트를 듣고, 킬해라.

# 8. 플랫폼 분기 처리

- 파일 이름으로 분기하기

```jsx
BigButton.ios.js;
BigButton.android.js;
```

- Platform

```jsx
Platform.OS === 'ios' ? 200 : 100
Platform.select -> 플랫폼 별 값 골라야할 때
```
