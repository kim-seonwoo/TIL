# Redux

## 핵심 개념

1. Store: 상태 저장 공간
2. Action: 상태 변경을 설명하는 객체
3. Reducer: action의 상태 변경을 정의하는 함수
4. Dispatch: action을 reducer에 전달하여 상태를 변경시키는 함수

→ 단방향 데이터 흐름을 유지하는 것이 관건

```jsx
// redux 패키지에서 함수 가져오기
import { createStore } from "redux";

// 1. Reducer (직접 작성)
const reducer = (state = { value: 0 }, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { value: state.value + 1 };
    default:
      return state;
  }
};

// 2. Store 생성 (redux 라이브러리 함수 사용)
const store = createStore(reducer);

// 3. Action (직접 작성)
const increment = { type: "INCREMENT" };

// 4. Dispatch (redux가 제공하는 store 메소드 사용)
store.dispatch(increment);

console.log(store.getState()); // { value: 1 }
```

- 이처럼 해당 상태와 상태변화 시키는 케이스들을 작성하여 상태를 관리

## 단점

- 보일러플레이트가 많음
- 비동기 처리가 어렵고, 코드가 길어짐

# Redux Toolkit

## 핵심 기본 내장 기능

1. configureStore() → 미들웨어 기본 포함으로 설정 단순화
2. createSlice → 액션과 리듀서를 한 번에 작성 가능하게 한다.
3. createAsyncThunk() → 비동기 로직 쉽게 작성 가능하게 한다.

```jsx
// @reduxjs/toolkit 패키지에서 가져오기
import { configureStore, createSlice } from "@reduxjs/toolkit";

// 1. createSlice로 reducer + action 한번에 작성
const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1; // immer가 적용돼 직접 변경처럼 작성 가능
    },
  },
});

// 2. Store 생성 (configureStore 사용)
const store = configureStore({
  reducer: counterSlice.reducer,
});

// 3. Action은 slice.actions에서 자동 생성
store.dispatch(counterSlice.actions.increment());
console.log(store.getState()); // { value: 1 }
```

- redux와 비교했을 때 간소화된 절차.
- 리덕스의 단방향 데이터 흐름을 사실 ssot를 위한거임.

# 단방향 데이터 흐름

- **Props**: 부모 → 자식 컴포넌트로만 데이터가 흐름
- **State**: 각 컴포넌트 내부의 로컬 상태를 관리

# SSOT (Single Source of Truth)

- 항상 상태를 단일 출처로 할 것

```jsx
import { postActivateLocation, postDeactivateLocation } from './location';
import { useGPSStore } from '../store/gpsStore';
import { WSMessage } from '../model/wsCard';

let socket: WebSocket | null = null;

export const WebSocketManager = {
	connect: (userId: string, latitude: number, longitude: number) => {
		if (socket && socket.readyState <= 1) {
			console.log('⚠️ 이미 연결된 WebSocket이 존재함');
			return;
		}

		socket = new WebSocket(`wss://scannect-be.onrender.com/ws?userId=${userId}`);
		console.log('🔗 WebSocket 연결 시도:', socket.url);

		socket.onopen = async () => {
			console.log('✅ WebSocket 연결됨');
			try {
				await postActivateLocation(userId, latitude, longitude);
				console.log('📡 위치 활성화 요청 전송 완료');
			} catch (e) {
				console.error('❗ 위치 활성화 요청 실패:', e);
			}
		};

		socket.onmessage = event => {
			try {
				const message: WSMessage = JSON.parse(event.data);
				console.log('📩 전체 수신 메시지:', message);

				switch (message.type) {
					case 'cardList':
						useGPSStore.getState().setGPSUserList(
							message.cards.map(card => ({
								id: card.userId,
								name: card.nickname ?? card.cardName ?? '이름없음',
								job: card.job,
								company: card.belongTo,
							}))
						);
						break;

					case 'request':
						useGPSStore.getState().setExchangeUserId(message.fromUserId);
						useGPSStore.getState().setExchangeCardId(message.cardId);
						break;

					case 'response':
						console.log(`🤝 [응답] ${message.fromUserId} → ${message.toUserId}: ${message.status}`);
						break;

					case 'notify':
						useGPSStore.getState().setNotifyMessage(message.message);
						break;

					case 'remove':
						useGPSStore.getState().removeUserById(message.userId);
						break;

					default:
						console.log('📦 알 수 없는 메시지 타입:', (message as any).type);
						break;
				}
			} catch (err) {
				console.error('❗ 메시지 파싱 실패:', err);
			}
		};

		socket.onerror = err => {
			console.error('❗ WebSocket 오류:', err);
		};

		socket.onclose = () => {
			console.log('❌ WebSocket 연결 종료됨');
		};
	},

	disconnect: async (userId: string) => {
		if (!socket) {
			console.log('⚠️ 연결된 소켓 없음');
			return;
		}
		socket.onclose = async () => {
			console.log('❌ WebSocket 연결 종료됨');
			try {
				await postDeactivateLocation(userId);
				console.log('📴 위치 비활성화 요청 전송 완료');
			} catch (e) {
				console.error('❗ 위치 비활성화 요청 실패:', e);
			}
		};
		socket.close();
		socket = null;
	},

	sendMessage: (data: WSMessage) => {
		if (socket && socket.readyState === WebSocket.OPEN) {
			socket.send(JSON.stringify(data));
			console.log('📤 메시지 전송됨:', data);
		} else {
			console.warn('⚠️ WebSocket이 연결되지 않았거나 준비되지 않음');
		}
	},
};
```

- connect에서 소켓을 생성하고 열어서, onMessage를 이용하여 메세지를 수신하게 하였고.
- disconnect에 onClose를 이용하여 소켓 연결을 끊었습니다.
- 그리고 sendMessage(socket.send) 를 통해 단발성으로 메시지를 전송하였습니다.

# WebSocket

- 웹 브라우저와 서버 간에 소켓 연결을 열어 두고 양방향 통신을 할 수 있는 프로토콜. (실시간)
- 표준 WebSocket API를 사용하면됨.
- 서버가 [socket.io](http://socket.io) 기반이라면, socket.io-client를 사용해줘야함.
- 백그라운드에서 유지가 필요한지 확인 필요.
- 끊겼을 때 재연결 로직이 필요한가?
- HTTP에 비해 헤더가 들어가지 않으므로, 가볍다.

1. WebSocket 객체를 생성해 준다.

- `socket = new WebSocket(`wss://scannect-be.onrender.com/ws?userId=${userId}``)

1. 다음과 같은 메서드로 통신

```jsx
socketRef.current.onopen = () => {
  console.log("✅ WebSocket Connected");
  reconnectAttempts.current = 0; // 성공하면 초기화
};

socketRef.current.onmessage = (event) => {
  console.log("📩 Message:", event.data);
};

socketRef.current.onerror = (err) => {
  console.log("❌ Error:", err.message);
};

socketRef.current.onclose = () => {
  console.log("⚠️ Disconnected, retrying...");
  retryConnect();
};
```

1. retryConnect와 같은 별도의 함수로 인터셉터 처럼 재연결 처리해준다.

```jsx
const retryConnect = () => {
  // 지수적 Backoff (최대 30초)
  const delay = Math.min(1000 * 2 ** reconnectAttempts.current, 30000);
  reconnectAttempts.current += 1;

  reconnectTimer.current = setTimeout(() => {
    console.log(`🔄 Reconnect attempt #${reconnectAttempts.current}`);
    connect();
  }, delay);
};

useEffect(() => {
  connect();

  return () => {
    clearTimeout(reconnectTimer.current);
    socketRef.current?.close();
  };
}, []);
```

> 백그라운드에서도 socket 돌아가게 할 수 있을까?
> iOS는 불가, 안드로이드는 가능
> → 그냥 APN과 같은 푸시알림 써라.

- JS에서는 정규표현식도 객체이다.

## 정규표현식 방식

### 리터럴 방식

```jsx
const regex = /hello/;
```

리터럴은 스크립트를 불러올 때 컴파일된다. 바뀔일이 없는 경우에는 리터럴을 사용하면 성능 향상!

### 생성자 방식

```jsx
const regex = new RegExp(word);
```

패턴이 바뀌는 경우에는 어쩔수 없이, 생성자 함수 이용.
이럴 경우 런타임에 컴파일됨.

### Escaping

- 역슬래시로 이스케이핑할 수 있음.

### 주요 메서드

- test() → 패턴이 있는지 확인해서 boolean
- exec() → 패턴 매칭된 부분을 배열로 반환
- String.place() → 문자열 형식을 원하는 패턴으로 치환하고 싶을때
- String.split() → 정규식 기준으로 나눠서 배열로 반환

## 특수문자

- 문자 클래스
  - `abc` → "abc"라는 문자열이 있는지 찾음
  - `.` → 임의의 문자 1개 (줄바꿈 제외)
  - `^` → 문자열 시작
  - `$` → 문자열 끝
  - `[abc]` → a 또는 b 또는 c
  - `[^abc]` → a,b,c 제외한 문자
  - `[0-9]` → 0~9 숫자
  - `[A-Za-z]` → 알파벳
  - `\d` → 숫자 `[0-9]`
  - `\D` → 숫자가 아닌 것
  - `\w` → 단어 문자(알파벳+숫자+\_)
  - `\W` → 단어 문자가 아닌 것
  - `\s` → 공백 문자 (space, tab, 개행)
  - `\S` → 공백이 아닌 것
- Assertions (앵커)
  - `^` → 문자열 시작
  - `$` → 문자열 끝
  - `\b` → 단어 경계
  - `\B` → 단어 경계 아님
- Group
  - (cat|dog) “cat” 또는 “dog”
- Quantifiers
  - → 0회 이상 반복
  - `+` → 1회 이상 반복
  - `?` → 0 또는 1회
  - `{n}` → 정확히 n번
  - `{n,}` → n번 이상
  - `{n,m}` → n~m번
- 플래그
  - `g` → 전역 검색 (여러 개 찾기)
  - `i` → 대소문자 구분 없음
  - `m` → 여러 줄 모드 (^,$가 각 줄의 시작/끝)
- 자주 쓰이는
  - ㄱ-ㅎ가-힣
  - a-zA-Z
  - 0-9
  - . (모든 문자열)

# 자주쓰이는 예제

- 이메일 검증

```jsx
const emailRegex = /^[\w.-]+@[\w.-]+\.[A-Za-z]{2,}$/;
console.log(emailRegex.test("test@example.com")); // true
```

- 문자열 처음부터 검사하며 (알파벳, 숫자, 문자, -)허용
  - @가 무조건 들어가기
  - 문자열 처음부터 검사하며 (알파벳, 숫자, 문자, -)허용
  - .이 무조건 들어가기
  - 문자열인데 2글자 이상으로 끝나야함.
- 휴대전화

```jsx
const phoneRegex = /^01[0-9]-\d{3,4}-\d{4}$/;
console.log(phoneRegex.test("010-1234-5678")); // true
```

- 01로 시작해야함 그리고 뒤에 숫자 하나
- - 가 들어감
- 가운데 3, 4자리 숫자
- 마지막 4자리 숫자로 끝남
