# 포인터

**포인터(Pointer)**란 **데이터가 저장된 메모리의 주소값을 저장하는 변수**이며, 포인터 변수라고도 부릅니다.

👉 메모리의 주소, 즉 ‘어디’인지(=위치 정보)를 저장하는 전용 변수!

**“포인터는 변수의 주소를 저장하는 또 다른 변수이다!”**

# 포인터가 중요한 이유

- 대용량 구조체를 가볍게 함수간 전달할 수 있다.
- 구조체가 엄청 커지면 이를 옮기는 데도 많은 메모리 자원이 들어간다.
- 포인터를 사용하면 구조체의 시작 주소만 가지고 모든 연산을 수행할 수 있다.

# 알고리즘

## 시간 복잡도

- 수행 시간 분석

## 공간 복잡도

- 메모리 사용량 분석

## 빅오 표기법

- 가장 빠르게 증가하는 항만을 고려하는 표기법

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2a65dd92-1694-460a-a843-42f41adf38d8/a7454d5d-00e8-40f5-8afd-1100acb7ac1a/Untitled.png)

- 핵심 아이디어만 잘 캐치하면 된다.
- return a, b, c, d → 패킹
- 이것을 a, b, c, d = func()로 언패킹 할 수 있다.

# 파이썬 라이브러리

- 내장함수, intertools, heapq, bisect, collections(counter), math

# 유클리드 호제법

*유클리드 호제법(- 互除法, Euclidean Algorithm)은 2개의 자연수 또는 정식(整式)의 **최대공약수(Greatest Common Divisor)**를 구하는 알고리즘의 하나이다.*

*호제법이란 말은 두 수가 서로(互) 상대방 수를 나누어(除)서 결국 원하는 수를 얻는 알고리즘을 나타낸다.*

*2개의 자연수(또는 정식) a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a>b), a와 b의 최대공약수는 b와 r의 최대공약수와 같다.이 성질에 따라, b를 r로 나눈 나머지 r'를 구하고, 다시 r을 r'로 나눈 나머지를 구하는 과정을 반복하여 나머지가 0이 되었을 때 나누는 수가 a와 b의 최대공약수이다.*

```swift

# 방법1
def gcd(m,n): # gcd == "Greatest Common Divisor"
	if m < n:
		m, n = n, m
	if n == 0:
		return m
    if m % n == 0:
		return n
	else:
		return gcd(n, m%n)

# 방법2
def gcd(m,n):
    while n != 0:
       t = m%n
       (m,n) = (n,t)
    return abs(m)

# 방법3
def gcd(m,n):
    while n! = 0:
	    if m < n:
		    m, n = n, m
	    if n == 0:
		    return m
	    if m % n == 0:
		    return n
```

- 계속 나머지를 구한다.

# 그리디 알고리즘

- 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 최소한의 아이디어를 떠올릴 수 있는 능력
- 정당성 분석이 중요
- 그리디 문제는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서 플리도록 출제가 됨.

## 거스름돈 문제

- 큰 돈 부터 거스를 수 있을만큼 최대한 거슬러줌

## 유형

- 최적의 옵션이 된다면 그것을 수행
- 아니면 다른 옵션을 수행
- 그리고 특정하게 예외 값이 있을 수 있음

# 구현: 시뮬레이션, 완전탐색

→ 풀이를 떠올리는 것은 쉽지만 소스코드로 옮기기 어려운 문제

하나 씩 그냥 다 세서 풀 수 있는 문제가 많음
→ 완전 탐색	

# DFS

- 그래프는 2차원 리스트로 나타낼 수 있음
- 현재 노드를 방문 처리
- 반목문으로  현재 노드와 연결된 다른 노드를 재귀적으로 방문

# BFS

- 큐 자료 구조를 이용
- 최단 경로 문제에서도 이용
- 현재 노드를 방문 처리
- popleft로 꺼낸다음에 인접한 노드를 큐에 삽입