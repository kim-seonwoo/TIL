**_파이썬 알고리즘 인터뷰 도서를 읽은 정리입니다_**

## 리트코드 사용 추천

# 1장 코딩 인터뷰

- 연습장과 필기도구 꼭 필요 → 생각하면서 풀기
- 모든 테스트케이스를 통과토록 → 제출 시도를 평가하는 기업도 간혹..
- 타임 아웃 → 시간 복잡도 측면 개선 필요
- 예외 처리 → 0 이나 null 처리해야 될 때도 있다.
- 잘못된 문제풀이 발견 → 스스로 문제당 제한 시간 둬서 그냥 넘어가기!
- 화이트 보드 → 질문 잘하기

# 2장 프로그래밍 언어 선택

- 제네릭 → 파라미터의 타입을 나중에 지정 → 파이썬 애초에 동적 프로그래밍 → 그래서 파이썬이 쉽다!

# 3장 파이썬 언어

- 리스트 컴프리헨션 → 가독성 고려 필요
- 제너레이터 → b = range(1000000)이런식이 더 메모리가 효율적
- enumerate(a) 자료 a를 인덱스와 함께한 튜플로 보내려면.
- divmod() , 몪 나머지 묶어서
- print → sep, end, join 이용하기
- pass → 빈 def 골격 잡을때 pass 넣고

# 4장 빅오

- O(n) → 정렬되지 않은 리스트에서 최댓값또는 최솟값.
- O(n log n) → 병합 정렬을 비롯한 효율 좋은 정렬 알고리즘.
- O(n^2) → 버블 정렬
- O(2^n) → 피보나치 수 재귀
- O(n!) → 외판원 문제 브루트포스

- 시간과 공간은 대부분 trade off 다.
- 변수에 string 선언? String의 주소를 참조하는 거다. → 따라서 str은 변경할 수 없으면서 불변이다. → List는 가변이다.
- int와 달리 long은 임의 정밀도를 가지고 있어 마치 수를 배열처럼 무한 리필함.
- 파이썬은 원시 타입의 속도를 포기했으나, 대신 객체의 다양한 기능과 편의성을 선택했다.
- is는 id 주소를 비교하는 함수이다.

# 5장 리스트 딕셔너리

- a.sort() → o(n log n) → 팀 소트
- min, max → O(n)
- reverse() → O(n)

### 리스트 삭제하는 방법

1. 인덱스로 삭제 del a[1]
2. 값으로 삭제 a.remove(3), a.pop(3)

- 파이썬은 모든 것이 객체며, 파이썬의 리스트는 객체에 대한 포인터 목록을 관리하는 형태로 구현되어 있다.
- Dict → 과거 버전은 입력 순서가 유지 안됨 (3.6 이하)

## 딕셔너리 모듈

1. defaultdict → 무 존재 값 조회해도 디폴트로 0으로 주면서 생성 시켜줌
2. Counter → list 던져주면 키에 수, value에 갯수로 매핑해줌 → most_common() 빈도수가 가장 많은 것을 조회 시켜준다.
3. OrderedDict → 입력 순서 유지 문제 해결.

# 6장 문자열 조작

### 1. 펠린드롬

- for문을 순회하는 방법

```jsx
char.isalnum().lower()
# 이렇게 한 채로 리스트에 append()
```

- while len(리스트) > 1
  pop(0) ≠ pop() → retrun False
  → deque popleft로 최적화 가능
- 슬라이싱을 응용하는 방법이 있다 `return s == s[::-1]
-> 은근 빠름`

### 2. 문자열 뒤집기

- 투 포인터 스왑하는 방법
- s.reverse() → 아니면 슬라이싱 → 파이썬 적인 방법

### 3. 로그 파일 재설정

- 람다 + 연산자

```jsx
letters.sort(key=lamda x : (x.split() [1:], x.split[x]))
```

### 4. 가장 흔한 단어

- collections.Counter(words)
  return counts.most_common(1)[0][0]
  → 가장 흔하게 응답하는 단어의 첫 번쨰 인덱스 리턴!

### 5. 그룹 애너그램

- 정렬하여 딕셔너리에 추가

### 정렬 방법

- sort() → 별도의 리턴이 없다.
- sorted(c, key=len) 이와 같이 설정 가능.

### 6. 가장 긴 펠린드롬 부분 문자열

- 중앙을 중심으로 확장하는 풀이
  → 투포인터 적인 문제를 많이 사용하는 듯??

# 7장 배열

동적 배열의 원리. 미리 초깃값을 작게 잡아 배열을 생성. → 늘려줌 그때 그때 Doubling

### 7. 두수의 합

- 브루트 포스 for 문 2중 중첩
- in을 이용한 차 구해서 탐색
- 첫 번째 수를 뺀 결과 키 조회
- 조회구조 개선
- 투 포인터

### 8. 빗물 트래핑(어려움)

- 투 포인터
- 스택 쌓기

### 9. 세 수의 합

- brute-force (3중 for문) → 하지마!
- 투 포인터 → for문의 i, left, right 잡고 for문 돌면서 조정

### 10. 배열 포지션 1 (min들의 합의 최대를 구하는 문제!)

- 오름차순 풀이
- 짝수 번쨰 값 계산 → [::2] → 슬라이싱 가능
