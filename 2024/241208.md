재귀로 짜는 경우가 많음.

sum(1) = 1

sum(n) = n + sum(n-1)

병합 정렬

전체 문제를 부분 문제로 풀면 하나하나가 작아지므로 문제 풀이가 간단해짐.

1. 문제를 분할
2. 분할된 부분 문제들을 풀고
3. 병합 → O(N) 밖에 소요되지 않음. 이미 다 정렬된 2개를 합치기 때문.

```python
def my_sum(n) :

if n == 1: retrun 1

return n + my_sum(n -1)
```

```python
def func(a,b):
	if b == 1: return a
	if b % 2: return a * func(a, b-1)
	half = func(a, b//2)
	return half * half
```

DP → 겹치는 부분문제가 있음 → 메모이제이션

분할 정복 → 겹치는 부분문제가 없도록 분할을 함 → 메모이게이션 같은게 없음
→ 겹치는 부분문제가 없도록 효율적으로 분할하는게 중요함.

- 정의를 잘하는 것이 중요함
- 정의 : 좌표 ()로 부터 크기가 sz인 사각형을 압축하는 함수
- 기저 사례
