**Closure는 값을 캡쳐할 때**

- 클로저의 캡쳐리스트가 무엇일까요?

**Value/Reference 타입에 관계 없이 Reference Capture 한다**

따라서, closure를 실행하기 전에 num이란 값을 외부에서 변경하면,

클로저 내부에도 값이 변경됨

Value Type도 가능함!

지금 공부하고 있는 **Capture Lists** 라는 것을 이용하면 할 수 있움!

Value Type의 경우**, Value Capture 하고 싶은 변수를 리스트로 명시**해주는 것임 !!! :)

혹은, 클로저 내부에서 num의 값을 바꾸면 외부 값도 변경됨

closure 내부에서 **Value Capture된 값을 변경할 수 없음**

정리하자면,

클로저는 기본적으로 Value Type의 값도 Reference Capture를 하지만,

클로져 캡쳐 리스트를 이용하면 Const Value Type으로 캡쳐가 가능 하구나!!

아니 (단호)

**캡쳐 리스트를 작성한다고 해도, Reference Type은 Reference Capture**를 함

그럼 **Reference Type은 클로저 캡쳐 리스트를 작성할 필요가 없겠네**!?!?

싶겠지만, 이건 클로저와 ARC를 보면 언제 쓰는지 이해할 수 있음

### **3-1. 클로저의 강한 순환 참조**

자, 먼저 클로저는 참조 타입으로, **Heap**에 살고 있음!

따라서, 내가 생성한 **human**이란 **인스턴스**는,

클로저에서 해결하려면 앞서 공부한 **weak & unowned**에

우리가 Reference Type일 땐 필요 없다 느꼈던 **캡쳐 리스트**를 이용해야 함

**weak & unowned**

**+**

**Capture Lists**

이 두가지를 이용해서 강한 순환 참조를 해결하는 것임 :)

결론: 레퍼런스 캡쳐, 클로저 강순참 가능성, so weak self

- ARC는 무엇일까요?
    - 왜 해당 개념이 존재하는 걸까요?!
    
    ## **ARC란**
    
    스택 메모리와 힙 메모리는 프로그래밍 언어에서 메모리를 할당하는 두 가지 주요 방법입니다.
    
    1. **스택 메모리(Stack Memory)**:
        - 스택 메모리는 함수 호출 및 지역 변수와 같은 임시 데이터를 저장하는 데 사용됩니다.
        - 스택 메모리는 후입선출(LIFO, Last-In-First-Out) 방식으로 동작합니다.
        - 함수가 호출될 때마다 해당 함수의 지역 변수와 매개변수가 스택 프레임에 저장됩니다.
        - 함수가 반환되면 해당 스택 프레임이 제거되어 스택 메모리에서 할당된 공간이 해제됩니다.
        - 스택 메모리는 메모리 관리가 간단하고 빠르지만, 크기가 제한되며 정적인 할당 방식을 사용합니다.
    2. **힙 메모리(Heap Memory)**:
        - 힙 메모리는 동적으로 할당된 데이터를 저장하는 데 사용됩니다.
        - 힙 메모리는 가비지 컬렉터 또는 수동으로 메모리를 해제해야 하는 메모리 관리 방식을 사용합니다.
        - 힙 메모리는 동적 할당된 데이터가 프로그램의 생명 주기 동안 지속되는 경우 사용됩니다.
        - 스택과 달리 힙은 메모리를 자유롭게 할당하고 해제할 수 있기 때문에 훨씬 유연하게 사용할 수 있지만, 메모리 누수와 같은 문제가 발생할 수 있습니다.
    - **자동**으로 **메모리 관리**해주는 좋은 친구
    - 객체에 대한 **참조 카운트를 관리**하고 **0**이 되면 자동으로 **메모리 해제**
    - run time에 계속 실행되는게 아니라 **complie time**(build 할 때)에 실행
    - 하지만 **retain cycle**에는 유의해야한다
    - 옛날 옛적 Objective-C에서는 **MRC**, 즉 수동으로 메모리 관리 했다
    
     ARC는 자동으로 `retain`, `release`를 삽입해서 `retainCount` 를 관리하고, 0이 될때 `deinit`을 호출해서 메모리 해제를 시킨답니다!
    **Heap 영역과 관련**되어 있습니다. Heap 은 class, closure 등의 **참조형(reference) 자료** 들이 머무는 공간이자, **개발자가 동적으로 할당**하는 메모리 공간이기 때문에 **관리가 필요**하기 때문이죠.
    - 
    - 
    
    **ARC는 클래스 인스턴스가 더 이상 필요하지 않을 때**
    
    **메모리를 자동으로 해제한다**
    
    1. 동적 할당으로 object가 생성되면 해당 정보는 HeapObject라는 struct로 관리됨
    2. HeapObject 안에는 reference count도 포함됨
    3. 따라서 class에 대한 HeapObject를 통해 reference count 관리 가능
    
    4. compile time에 코드 분석을 통해 적절한 위치에 `retain`, `release` 등의 코드를 삽입해 줌
    5. 삽입된 코드는 run time에 실행됨
    6. `retain`, `release`를 통해 `referenceCount`를 증감시키다가 count 가 0이 되면 `deinit` 을 통해 해제 시킴
    7. `referenceCount` 는 동적 할당된 object를 표현하는 `HeapObject` struct에서 접근 가능
    
    다시 말해 **RC**는
    
    **이 인스턴스를 현재 누가 가리키고 있느냐 없느냐(참조하냐 안하냐)를**
    
    **숫자로 나타낸 것**임 ㅎㅎ
    
    만약 참조 횟수가 10이라면
    
    해당 인스턴스가 10군데에서 참조되고 있단 뜻이고,
    
    참조 횟수가 0이라면
    
    아무데서도 참조되지 않으니 필요없다! 메모리 해제해라! 란 뜻임
    
    참조 횟수가 +1이 되는 순간은
    
    **인스턴스의 주소값을 변수에 할당할 때** 임
    
    함수가 종료되어 **지역변수 clone이 스택에서 해제되는 순간** 인스턴스의 **RC -1**이 됨
    
    **인스턴스의 주소값이 변수에 할당될 때,**
    
    **RC가 증가하면 강한 참조(strong)** 인 것임
    
    우리가 지금껏 자연스럽게 인스턴스를 생성하고 사용하던 것이
    
    다 strong이자 강한 참조였던 것임
    
    근데 난 strong으로 선언한 적 없는뎅!?ㅎ_ㅎ  하겠지만
    
    별다른 선언이 없다면
    
    **default 값이 strong**
    
    임 ㅎㅎㅎㅎ
    
    따라서 위에서 sodeul로 생성한 인스턴스는 default인 s**trong**으로 선언되어
    
    '**강한 참조**' 객체인 것임!!!!
    
    순환 참조
    
    Man, Woman 클래스의 **deinit 메서드가 호출되지 않음**
    
    deinit 함수는 인스턴스가 메모리에서 해제될 때 실행되는 메서드임
    
    (만약 진짜 deinit 메서드가 호출되지 않는지 궁금하면 위 예제를 직접 돌려보셈 :))
    
    그말인 즉,
    
    **철수와 영희가 가리키던 인스턴스가 힙에서 사라지지 않고**
    
    **계속 메모리를 먹고 있단 말임**
    
    약한 참조란 무엇이냐면
    
    **인스턴스를 참조할 시, RC를 증가시키지 않는다**
    
    **참조하던 인스턴스가 메모리에서 해제된 경우, 자동으로 nil이 할당되어 메모리가 해제된다**
    
    자 이 두가지가 핵심임
    
    **프로퍼티를 선언한 이후, 나중에 nil이 할당**된다는 관점으로 보아
    
    **weak는 무조건 옵셔널 타입의 변수 여야함
    둘 중에 수명이 더 짧은 인스턴스를 가리키는 애를 약한 참조로 선언함**
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2a65dd92-1694-460a-a843-42f41adf38d8/cbb1f037-2cc6-485a-9a9f-7472e628b53b/Untitled.png)
    
- Delegate패턴과 클로저를 사용한 데이터 전달 복습해주세요!

# Delegate

1. 프로토콜 구현 하기
2. delegate  프로퍼티 선언하기
3. 할일을 지시하는 함수 구현하기
4. delegate = self하기
- 두 개의 클래스를 델리게이트 패턴을 사용해 연결할 경우, Strong Reference Cycle이 생길 수 있으므로 주의해야 한다
5. 지시 받은 동작을 대리자에서 대신 처리하기

**장점**

프로토콜 사용으로 뛰어난 재사용성.

- 객체간의 의존성을 낮출 수 있음

프로토콜에 필요한 메소드들이 명확하게 명시되며 정보 전달도 가능.

객체 지향 프로그래밍을 따름. (처리할 일의 일부를 다른 객체에게 위임함)

로직의 흐름을 따라가기 쉬움.

**단점**

많은 줄의 코드가 필요.

delegate 설정에 nil이 들어가지 않게 주의해야함. (크래시를 발생 가능성)

많은 객체들에게 이벤트를 알려주는 것이 어렵고 비효율적임.

delegating 객체는 `delegate` 프로퍼티를 통해 상대 객체를 강하게 참조하고 있고, delegate 객체 역시 delegating 객체를 강하게 참조하고 있기 때문에 Strong Reference Cycle이 생기게 되는 것이다.

`delegate` 프로퍼티를 선언할 때는 weak로 선언하거나 delegate를 담당하는 별도의 객체를 생성하는 등의 방식으로 Strong Reference Cycle을 피할 수 있다.

예를 들어 두개의 뷰컨트롤러 사이에 데이터 전달을 위해 델리게이트 패턴을 사용한 경우, delegating 객체는 `delegate`프로퍼티를 통해 상대 객체를 참조하고 있고, delegate 객체도 프로퍼티 등을 통해 delegating 객체를 참조하고 있어 서로를 강하게 참조하고 있게 된다.

이렇게 되면 하나의 뷰컨트롤러가 팝돼서 사라진다고 해도 메모리에서 해제되지 않아 메모리 누수가 생긴다!!!!

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/2a65dd92-1694-460a-a843-42f41adf38d8/2ceb0862-4052-4d7a-8934-d60577d082d7/Untitled.png)

# Closure

***클로저(Closure)란?***

- *클로저는 사용자의 **코드 안에서 전달되어 사용할 수 있는 로직을 가진** 중괄호“**{}**”로 구분된 **코드의 블럭**이며, **일급 객체의 역할**을 할 수 있다.*
- ***일급 객체는 전달 인자로 보낼 수 있고, 변수/상수 등으로 저장하거나 전달할 수 있으며, 함수의 반환 값이 될 수도 있다.***
- ***참조 타입**이다.*
- ***함수**는 클로저의 한 형태로, **이름이 있는 클로저**이다.*

# **값 캡쳐(Capturing Values)**

: 클로저는 특정 문맥의 상수나 변수의 값을 캡쳐할 수 있다. 즉 **원본 값이 사라져도 클로저의 body 안 에서 그 값을 활용할 수 있다.**

Swift에서 값을 캡쳐하는 가장 단순한 형태는 중첩 함수로 아래는 이에 대한 예시이다.

Closure란?

일정 기능을 하는 코드를 하나의 블록으로 모아놓은 것.

func 키워드를 사용하여 만들었던 함수도 named closure라고 한다.

- 어떤 상수나 변수의 참조를 캡쳐해 저장할 수 있다.
- 클로저를 변수나 상수에 대입할 수 있다.
- 함수의 파라미터로 클로저를 전달할 수 있다.
- 함수의 반환 타입으로 클로저를 사용할 수 있다.

- Any, AnyObject에 대해 알아보세요!

### **Any 타입**

**정의: `Any` 타입은 Swift의 모든 타입의 인스턴스를 나타낼 수 있습니다. 이는 함수 타입을 포함한 모든 데이터 타입을 의미합니다. 2사용 예시: 변수나 상수에 `Any` 타입을 지정하면, 어떤 종류의 데이터든 저장할 수 있습니다. 이는 다양한 타입의 데이터를 하나의 배열이나 딕셔너리에 저장할 때 유용하게 사용될 수 있습니다. 4주의 사항: `Any` 타입 변수는 타입 캐스팅을 통해 실제 타입을 확인해야 하며, `Any`와 `AnyObject` 타입은 생성자를 제공하지 않습니다. 3**

### **AnyObject 타입**

**정의: `AnyObject` 타입은 어떤 클래스 타입의 인스턴스도 참조할 수 있습니다. 하지만, 이는 클래스 타입에만 국한되며, 참조 타입인 클로저와 같은 타입에는 사용되지 않습니다. 8사용 상황: `AnyObject`는 주로 클래스의 인스턴스를 다룰 때 사용됩니다. 예를 들어, Objective-C와의 호환성을 위해 사용되거나, 클래스 인스턴스만을 포함하는 배열을 만들 때 유용합니다.**

**89**

+100

제네릭은 유형에 안전합니다. 즉, 문자열을 제네릭으로 전달하고 정수로 사용하려고 하면 컴파일러에서 문제가 발생하여 컴파일할 수 없게 됩니다(좋은 결과입니다). (이것은 Swift가 **정적 타이핑을 사용하고 있기 때문에 발생하며 컴파일러 *오류를*** 발생시킬 수 있습니다 )

AnyObject를 사용하는 경우 컴파일러는 객체가 문자열로 처리될 수 있는지 또는 정수로 처리될 수 있는지 전혀 모릅니다. 이를 통해 원하는 것은 무엇이든 할 수 있습니다(나쁜 일입니다).

*Generics는 기본적으로 컴파일러에게 다음을 알려줍니다.*

> "나중에 유형을 제공할 예정이며 내가 지정하는 모든 곳에서 해당 유형을 적용하기 를 바랍니다."
> 

*AnyObject는 기본적으로 컴파일러에게 다음과 같이 지시합니다.*

> " 여기서 어떤 유형도 강제할 필요가 없는 이 변수에 대해 걱정하지 마세요 . 제가 원하는 것은 무엇이든 하도록 놔두겠습니다."
> 
- inset, offset 공부하고 정리해보세요!
- SafeArea는 무엇일까요?

**시스템에 의해 가려질 수 있는 부분의 마진을 자체적으로 가지는 것이 Safe Area**이다

Safe Area는 아이폰x부터 만들어졌다.