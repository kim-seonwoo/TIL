# 식 및 연산자

- `*표현식: 값으로 평가될 수 있는 모든 것*`

## 더하기(+)

- 값을 모두 원시값으로 변환시키고 연산 실행
- 한 쪽이라도 문자열이라면, 둘다 문자열 취급하여 합침.

```jsx
console.log("a", [] + []);
console.log("b", [] + {});
console.log("c", {} + []);
```

![스크린샷 2025-09-10 오후 6.00.32.png](attachment:b5e48ae9-1cbe-4b79-b3df-1b6614461a0b:스크린샷_2025-09-10_오후_6.00.32.png)

## 할당 (=)

- 변수에 값을 할당 뿐만 아니라, 값도 반환함 사실

```jsx
let x;
console.log((x = 10)); // 10 출력
```

- 동등 연산자, 일치 연산자 (암묵적 변환 불확실성때문에 === 권장)

```jsx
// == (동등, 타입 강제 변환 발생)
console.log(5 == "5"); // true  ← 문자열 "5"가 숫자 5로 변환됨
console.log(false == 0); // true  ← false → 0
console.log(null == undefined); // true (특수 규칙)

// === (일치, 타입 변환 없음)
console.log(5 === "5"); // false ← 타입 다름
console.log(false === 0); // false ← 타입 다름
console.log(null === undefined); // false
```

- 구조 분해 할당
  - 내가원하는 이름으로 할당한다!
  - … rest파라미터를 이용하여 남는 값을 따로 모을 수 있음

```jsx
const [a, b, ...rest] = [1, 2, 3, 4];
const { name, age } = { name: "Jim", age: 25 };

console.log(a, b);
console.log(name, age);
```

![스크린샷 2025-09-10 오후 6.03.46.png](attachment:3f71a517-45f4-4e7b-a14a-d8f402faba69:스크린샷_2025-09-10_오후_6.03.46.png)

## async function 표현식

- async가 붙은 함수는 항상 Promise를 반환하는 거임 (자체가 하나의 비동기적인 것이기 때문에)
- async 내부적으로도 비동기적인 promise적인 요소가 온다? 그러면 awiat와 함께 풀어서 자주 씀. await로 앞선 promise가 resolve되었을때만 다음 프로세스 진행.
- await는 마이크로테스크 큐에 등록시키고 실행시키면서 비동기 함수를 순차적으로 처리해야할때 사용 (Promise.then과 같음)

### 마이크로테스크 큐????

- 자바스크립트 런타임은 이벤트 루프를 통해 실행됨.
- 이벤트 루프는

1. Call Stack: 지금 실행중이 코드
2. **Microtask Queue (마이크로태스크 큐)**: `Promise.then`, `catch`, `finally`, `queueMicrotask`, `await` 뒤 코드.
3. Task Queue: `setTimeout`, `setInterval`, `setImmediate`, DOM 이벤트 같은 큰 단위 작업.

순서로 먼저 처리시키는데..

만약 이렇게 async awiat을 쓴다면..

```jsx
async function foo() {
  console.log("A");
  await Promise.resolve();
  console.log("B");
}
foo();
console.log("C");
```

이런식으로 내부적으로 변환됨

```jsx
function foo() {
  console.log("A");
  return Promise.resolve().then(() => {
    console.log("B");
  });
}
foo();
console.log("C");
```

콜스택 빠지고 마이크로태스크 큐에 Promise 해당 부분을 등록 시키면

```jsx
function foo() {
    console.log("A");
    return Promise.resolve().then(() => {
        console.log("B");
    });
}
foo();
**setTimeout(() => console.log("D"));**
console.log("C");
```

- 출력
  ![스크린샷 2025-09-10 오후 6.37.18.png](attachment:f7b12ed1-a8ba-4a09-8534-476a5a567036:스크린샷_2025-09-10_오후_6.37.18.png)

# 쉼표 연산자

- 배열과 객체에 구분 용도로 쓰이는 거랑은 좀 다름.
- 왼쪽에서 오른쪽으로 평가하고, 마지막 값만 결국 반환.

```jsx
let a, b;
a = ((b = 2), (b = 3), (b = 4), b + 1);
console.log(a); // 3
```

- 우선순위가 가장 낮아서 쓸라면 괄호로 묶는게 거의 필수!

# 삼항 연산자

```jsx
condition ? True : False;
```

- 어떤 조건과 이 값이 truthy하냐 falsy하냐?
- 예를 들어 null 값이면 falsy함으로 False부분 반환
- JSX와 조합

```jsx
{
  isLoading ? <Spinner /> : <Content />;
}
```

# delete 연산자

- 해당 객체의 속성을 제거하는 연산자
- 메모리를 직접적으로 해제하지는 않는다. undefinced 반환
- 배열에서 삭제해도 마찬가지이다. 빈 슬롯의 형태로 남는다.
- 따라서 length를 찍어도, 삭제 후 변동이 반영이 안될수도

# 나누기 연산자

- 0으로 나눴을 때 특별한 값으로 반환한다. `Infinity`

# 함수 표현식

```jsx
const square = function (x) {
  return x * x;
};
```

- 다음과 같이 변수에 할당
- **함수 선언문**: 끌어올림(hoisting) 됨. 코드 어디서든 사용 가능.
- **함수 표현식**: 변수에 할당되므로 정의 전에 호출 불가.
- 함수표현식은 클로저를 만드는데 핵심적이다. (정해진 스코프를 기억)

```jsx
function makeCounter(plusmout) {
  let count = 0; // 1. makeCounter 함수 스코프 안의 지역 변수
  return function () {
    // 2. 익명 함수(내부 함수)를 반환
    return (count += plusmout); // 3. 외부 변수 count에 접근해서 1 증가 후 반환
  };
}

const counter = makeCounter(5); // 4. makeCounter 실행 → 내부 함수 반환

console.log(counter()); // 5
console.log(counter()); // 10
```

# import

### 정적 import

- 정적 import : 흔하게 아는 import 느낌

```jsx
import fs from "node:fs";
import { readFile } from "node:fs/promises";
```

- 코드 최상단에서만 사용 가능.
- 컴파일 시점에 결정된다.
- 동기적으로 불러옴.

### 동적 import

- 실행 중에 원할때 지연 로딩시킬 수 있음.

```jsx
if (something) {
  const { default: myFn } = await import("./myModule.js");
  myFn();
}
```

- Default Export → 한 모듈에서 단 하나만 export 할 경우

```jsx
export default function Button({ title }) {
  return <Text>{title}</Text>;
}

// import MyBtn from "./Button";
// 임포트 할때 default이면 원하는 이름으로 바로 저렇게 받아도 됨
```

- Named export: 여러개 export

```jsx
export const data1 = "1";
export const data2 = "2";

import { data1, data2 } from "./utils";

//반드시 같은 이름
```

- 경로 alias → 경로 단축 가능!

```jsx
// babel.config.js
plugins: [
  [
    "module-resolver",
    {
      alias: {
        "@components": "./src/components",
      },
    },
  ],
];
```

```jsx
import Button from "@components/Button";
```

- Barrel 패턴 (index.js)

```jsx
// screens/index.js
export { default as HomeScreen } from "./HomeScreen";
export { default as DetailScreen } from "./DetailScreen";
```

```jsx
import { HomeScreen, DetailScreen } from "../screens";
```

import 경로를 단축하고, 모듈 정리 쉬워짐.

# in 연산자

- 객체에 해당 키값이 있냐 검사.
- 배열, Map 이런 거 다 객체로 생각해야함.

```jsx
const arr = ["a", "b", "c"];
console.log("length" in arr);
// array를 객체로 풀면 항상 length 속성을 가지고 있음. 그래서 true
```

# Super

- `super`는 **부모 생성자나 메서드를 호출/참조**하는 키워드
- 이렇게 불러와도 읽기 전용이고, super 자체를 변수처럼 조작할수는 없음
- super는 정의 시점에 고정되는 거임

# this

- JS에서 this는 고정이 아니라, 선언시가 아니라, 호출시에 참조되는 객체.

```jsx
const user = {
  name: "Jim",
  sayName: function () {
    return this.name;
  },
};

console.log(user.sayName()); // "Jim"

// 객체의 프로퍼티로 호출되면 해당 객체를 가리킴
```

```jsx
const fn = user.sayName;
console.log(fn()); // undefined (strict) or window.name (비엄격)

// 변수로 빼면 this 잃어버림
```

- 화살표 함수는 자신만의 this를 가지지 않고, 외부 스코프를 캡쳐한다.

```jsx
const obj = {
  value: 100,
  regular: function () {
    return function () {
      return this.value;
    };
  },
  arrow: function () {
    return () => this.value;
  },
};

console.log(obj.regular()()); // undefined (this 잃음)
// 독립적으로 실행되므로 더이상 this는 obj가 아님
console.log(obj.arrow()()); // 100 (this 유지됨)
// 자신만의 this를 가지지 않고 캡쳐해서 사용함
const fn = obj.arrow;
console.log(fn());
```

# typeof

- 값의 타입을 문자열로 반환하는 단항 연산자

```jsx
typeof "hello"; // "string"
typeof 42; // "number"
typeof true; // "boolean"
typeof undefined; // "undefined"
typeof Symbol(); // "symbol"
typeof 123n; // "bigint" (ES2020)
typeof function () {}; // "function"
typeof { a: 1 }; // "object"
typeof [1, 2, 3]; // "object"

typeof null; // "object"
// null 버그
```

- null 버그 여담:

JS만드신 분이 10일만에 만들었는데,
객체랑 null 둘다 타입태그 0으로 걸어버림,
근데 JS 너무 빨리 퍼져버려서 호환성 이슈때문에 지금까지 못바꿈..

# Void

- void 앞에 붙이면, “이 표현식 실행은 하는데 undefined로 돌려줘”
- 화살표 함수에서 원래 `{}` 없으면 자동 리턴되는데, 실행만하고 싶고 리턴은 안하고 싶다?

```jsx
button.onclick = () => void doSomething();
```

- 추가적으로 ts 코드에서 void가 종종 타입으로 등장했는데,
  반환값을 무시한다는 의미로 쓰임

```jsx
interface ButtonProps {
  onClick: () => void;
}
```

→ 즉 함수는 받지만 반환값은 신경 안쓸때
