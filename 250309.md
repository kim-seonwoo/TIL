# Day5. Novice High 후

# 트리

- 사이클이 존재하면 트리가 아님.
- 이진 트리: 자식의 수를 최대 2개로 제한.
- 따라서 이진트리는 어느정도 배열로도 적을 수가 있다. 어느정도 순서를 예측 가능하기 때문.
- ‘이진 탐색 트리: 부모의 왼쪽 방향에 있는 노드들은 전부 부모 보다. 값이 작아야 하고, 부모의 우측 방향에 있는 노드들은 전부 부모보다 값이 커야한다.

# 이진 탐색 트리에 새로운 노드를 추가하는 방법

1. 트리에 노드가 전혀 없으면
   parent null, root를 node(x)로
2. parent 값이 있으면
   → 대소를 비교해 왼쪽 혹은 오른쪽에 넣어줌

# 이진 탐색 트리 삭제

- 복잡함

1. 해당 삭제할 노드를 찾고, 오른쪽 혹은 왼쪽 노드가 비어있다면, 위로 올려준다. 아래에 있는 한쪽에만 있는 노드들을 밀어 옮겨 주는 거임
2. 왼쪽 오른쪽 다 채워졌있다면?
   Successor를 찾아야함.
   현재 노드 기준으로 더 크면서, 가장 작은 값을 갖는 노드. (즉, 오른쪽 노드의 왼쪽 끝까지 내려감)

# 균형잡힌 이진 탐색 트리

- Red Black Tree, AVL Tree

# 힙

- 특별한 이진 트리
- 추가 삭제 시 O(log N)의 구조 유지 사용
- 최대 최소값이 루트 O(1)
- 만드는 시간 O(N)
- 최대값에 관련한 연산이 빈번한 경우에만 사용
- heapify : 현재 노드를 기준으로 이 노드가 heap 특성에 맞을 때까지 계속 밑으로 내려주는 과정

# 해싱

- 해시 함수: 임의의 데이터를 받아, 해당 데이터를 고정된 길이의 특정값으로 반환하는 함수.
- 해시 충돌 : 연결리스트 이용으로 해결.

# DP

- 동적 계획법: 작은 문제를 먼저 해결한 다음. 그 결과를 이용해 더 큰 문제를 해결
- for loop를 이용하거나, 점화식을 이용

# 메모이제이션

- 탑다운 방식

```python
function fibbo(n):
	if memo[n] != -1:
		return memo[n]
	if n <= 2
		memo[n] = 1
	else
		memo[n] = fibo(n - 1) + fibo(n - 2)

	return memo[n]
```

# Tabulation

- 바텀업 (조금 더 빠르다)
- for 문 돌면서 밑에 부분 부터 차근 차근히 계산
