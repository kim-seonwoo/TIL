# 24.02.23

# **View Protocol**

**@ViewBuilder**

- @resultBuilder를 사용하여 정의한 struct 형
- body는 ViewBuilder로 정의되어 있고, 이것은 @resultBuilder를 사용했으므로 아래처럼 콤마 없이 뷰를 나열하여 사용할수가 있음
- View의 특징은 class형태가 아닌, value type을 사용하기 위해서 Struct로 정의

**SwiftUI에서 뷰들을 Struct으로 정의하는 이유?
→ 간편하다 ! :  무겁게 상속을 하는 기존의 UIView와 다르게 SwiftUI의 View는 ViewModeifier 개념을 이용해 컴포넌트화 해서 최소화**

→ Struct! : Value Type을 이용하여 가변성을 최소화 함, 또한 메모리 릭 방지에 효과적임.

# **Localization, ViewModifier, Text ViewModifiers 개념**

## **Localization**

- SwiftUI에서는 그냥 Text에 키를 사용하여 적용
- UIKit처럼 NSLocalizedString을 따로 쓰지 않아도 편리하게 적용이 가능
- Localizable.strings로 String file을 생성해 준다.
- Localize 버튼을 클릭하고, Project > Localizations에 + 버튼을 클릭하여 지역화를 추가 가능
- Text 값에 따로 바로 리터럴로 연결

```swift
Text("my_text")
```

```swift
ContentView()
        .environment(\.locale, .init(identifier: "en"))
```

- 다음과 같이 프리뷰에서도 쉽게 지역화 설정을 할 수 있다.

## ViewModifier

- SwiftUI에서는 View들이 Class가 아닌 Struct에서 사용할 수 있기 때문에 상속이 불가능하여, 대신 `Modifier`라는 개념을 정의
- ViewModifier란 원래의 View에 커스텀 뷰처럼 미리 정의해놓고 이것을 다른 Text에서 가져다가 사용할 수 있는 기능 (= 상속 기능)

## **Text ViewModifier**

- **ViewModifier를 이용하여 커스텀 뷰 비슷하게? 만들 수 있다**
- 사용 예

```swift
import SwiftUI

struct MyTextModifier: ViewModifier {
  func body(content: Content) -> some View {
    content
      .font(.system(size: 24, weight: .bold, design: .default))
      .foregroundColor(.blue)
  }
}
```

```swift
struct ContentView: View {
  var body: some View {
    Text("my_text")
      .modifier(MyTextModifier())
  }
}
```

- 반복되는 스타일링을 단순화할 수 있을 것이라고 생각됨!

# TextField

- 값을 입력받을 수 있는 컴포넌트
- SwiftUI에서는 @State 상태 프로퍼티 하나를 두고 값이 입력되면 여기에도 입력되도록 구현

```swift
enum Field {
    case username
    case email
  }

@State private var username = ""
@State private var email = ""

@FocusState private var focusField: Field?

  var body: some View {
    VStack {
      TextField(
        "User name",
        text: $username
      )
      .focused($focusField, equals: .username)
      
      TextField(
        "Email",
        text: $email
      )
      .focused($focusField, equals: .email)
      
      ...

Button("Sign in") {
        if username.isEmpty {
          focusField = .username
        } else if email.isEmpty {
          focusField = .email
        } else {
          print("Complete Input and sign in...")
        }
      }
```

- @FocusState를 이용하여 텍스트 필드에 대한 포커스를 제어할 수 있다.
- `.focused($focusField, equals: .username)` 과 같이 바인딩을 시켜줘야함에 유의!

## 키보드 숨기기

```swift
extension View {
  func hideKeyboard() {
    UIApplication.shared.sendAction(#selector(UIResponder.resignFirstResponder), to: nil, from: nil, for: nil)
  }
}
```

# Image

- 공간에 맞게 이미지 크기를 조정하는 모드 설정
    - resizable()를 선언
    - 화면에 맞추어서 채워지는 효과
- .scaledToFit() == .aspectRatio(contentMode: .fit)

# Button

- 버튼 스타일에는 5가지가 존재
    - .default - 파란색 버튼
    - .plain - 일반 Text 형태 그대로 따라가는 버튼
    - .bordered - 버튼의 tint색상을 기반으로 자동으로 테두리에 어울리는 색상이 생기는 버튼
    - .borderedProminent - 버튼의 tint색상을 기반으로 텍스트가 `눈에 띄도록` 해주는 스타일
    - .borderless - 테두리가 없는 버튼 (= .default와 동일)

## 커스텀 버튼

```swift
struct ScaleButton: ButtonStyle {
  func makeBody(configuration: Configuration) -> some View {
    <#code#>
  }
}
```

```swift
struct InsetRoundButton: ButtonStyle {
  var labelColor = Color.white
  var backgroundColor = Color.blue
  
  func makeBody(configuration: Configuration) -> some View {
    configuration.label
      .foregroundColor(labelColor)
      .padding(.init(horizontal: 20, vertical: 13))
      .background(Capsule().fill(backgroundColor)) // <-
  }
}
```

```swift
Button("InsetRoundButton") {
  print("tap button")
}
.buttonStyle(InsetRoundButton(labelColor: .white, backgroundColor: .blue))
```

# Picker

- 개념: 상호 배타적인 값들을 선택할때 사용하는 UI
- 사용예

```swift
Picker("Flavor", selection: $selectedFlavor) {
  ForEach(Flavor.allCases) { Text($0.rawValue.capitalized) }
}
.pickerStyle(.wheel)
```

# **NavigationView, NavigationLink**