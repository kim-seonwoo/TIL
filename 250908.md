# Object

- **_자바스크립트의 모든 것이 객체를 기반으로 동작한다._**
- 객체는 원시 타입과 다르게 복사가 아니라 참조가 전달이 된다.
- 객체는 다 프로토타입 기반 상속이다.
- 참조가 바뀌어야 렌더링 된다는 점에서 프론트 개발자들이 주의해야된다.

## Intro

- 주어진 값이 null 또는 undefined이면 빈 객체를 생성해서 반환함.
- 그렇지 않으면 주어진 값에 해당하는 타입의 객체를 반환.

## 생성

- 생성자 컨텍스트: new를 붙여서 생성자 함수로 동작.
  const p = `new Person(’Kim’)`
  `클래스` 컴포넌트 같은 느낌에 많이 씀. this를 쓰는 특징. 객체를 명시적으로 만드는 느낌
- 비생성자 컨텍스트: const p = `Person(’Kim’)`
  리액트에서는 이렇게 `함수` 호출하듯이 많이 씀. 컴포넌트 느낌

## 정적 메서드

- Object 클래스 자체에 구현. 결국 객체라면 다 쓸수있는 메서드.
- Object.assign

```jsx
const returnedTarget = Object.assign(target, source);

console.log(target);
// Expected output: Object { a: 1, b: 4, c: 5 }
```

특징: target객체에 뒤에오는 값들이 덮어씀.

RN에서 **스타일 병합**이나 상태 업데이트에 자주 활용.

유의해야될 것은 얕은 복사라서 참조만 복사됨. 객체를 새로 만드는 건 아님. (상태관리 관련 조심!)
→ 보통 assign대신 스프레드 연산자로 풀어서 많이 쓴다.

- Object.create(proto)
  단순 복사가 아니라 프로토타입을 받아서 새 객체를 생성
  개발자가 실제로 자주 쓰지는 않지만 내부적으로는 다 이렇게 상속받아서 이루어져있음.으로는 다 이러
- Object.defineProperties()
  객체의 속성을 정의한다.

```jsx
Object.defineProperty(o, "a", {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true,
});
```

writiable 과같은 정보 설정 때문에, 라이브러리에서 읽기전용이고 그런 것이다.

- Object.entries

객체를 **[key, value] 쌍의 배열**로 변환.

객체를 곧바로 JSX로 렌더링 할 수 없으니, 풀어주는 역할. FlatList나 Map에 많이 사용함.

```jsx
function UserInfo(props) {
  return (
    <View>
      {Object.entries(props).map(([key, value]) => (
        <Text key={key}>{`${key}: ${value}`}</Text>
      ))}
    </View>
  );
}
```

- Object.fromEntries()는 배열을 다시 객체로 만들어줌
- Object.freeze(), Object.seal()

![스크린샷 2025-09-08 오후 6.56.55.png](attachment:fba5a20a-e5a0-4ee5-954a-445f31872a22:스크린샷_2025-09-08_오후_6.56.55.png)

- `freeze`: **"완전한 상수"** → 테마, 팔레트, 변하지 않는 전역 값
- `seal`: **"틀은 고정, 값은 유동적"** → 구조는 보호하되 값만 바꾸고 싶은 설정 객체
- Object.getPrototypeOf(obj) → 이 객체 부모( 프로토타입 )은 무엇인지 알고 싶을때
- **Object.groupBy() → Object.groupBy(items, callbackFn)
  callbackFn에서 정의된 요소에 따라서 그룹화 할 수 있음.**

```jsx
const result = Object.groupBy(inventory, ({ type }) => type);

/* Result is:
{
  vegetables: [
    { name: 'asparagus', type: 'vegetables', quantity: 5 },
  ],
  fruit: [
    { name: "bananas", type: "fruit", quantity: 0 },
    { name: "cherries", type: "fruit", quantity: 5 }
  ],
  meat: [
    { name: "goat", type: "meat", quantity: 23 },
    { name: "fish", type: "meat", quantity: 22 }
  ]
}
*/
```

- Object.hasOwn()
  **→ 객체에서 상속되지 않고, 자체적으로 지정한 속성이 있는가?**
- Object.is()
  **`===`와 같지만, 두 가지 예외**가 있다.

```jsx
console.log(NaN === NaN); // false
console.log(Object.is(NaN, NaN)); // true

console.log(+0 === -0); // true
console.log(Object.is(+0, -0)); // false
```

useState 쓸때, false일때만 리렌더하므로 알아둘필요있음.

- Object.isExtensible(obj)

```jsx
const obj = {};
console.log(Object.isExtensible(obj)); // true

Object.preventExtensions(obj);
console.log(Object.isExtensible(obj)); // false

// 객체 확장을 명시적으로 막는 경우!
```

- Object.keys(obj), Object.values(obj)
  → 배열로 키나 밸류를 반환한다.

```jsx
const fruits = { a: "Apple", b: "Banana", c: "Cherry" };

<Object.values(fruits).map((fruit, i) => (
  <Text key={i}>{fruit}</Text>
))>

// 이런식으로 map으로 순회할때 많이 사용!

```

# 인스턴스 메서드

`Object.prototype`에 정의 → 모든 객체 인스턴스가 상속받음.

- obj.hasOwnProperty(key)
  객체 자신이 직접 가진 속성인가
- obj.toString()
  객체자체를 문자열로 변환
- obj.valueOf()
  객체의 원시값을 반환

```jsx
console.log((42).valueOf()); // 42
console.log(new Number(42).valueOf()); // 42
```

- obj.propertyIsEnumerable(key)
  → enumerable이 어떻게 설정되어있냐?

```jsx
const obj = {};
Object.defineProperty(obj, "hidden", { value: 1, enumerable: false });
// enumerable 직접 조회는 가능하지만, 순회나 리스트로 키값 뽑았을때 조회안됨
console.log(obj.propertyIsEnumerable("hidden")); // false
```

# 인스턴스 속성

- Object.prototype.**proto
  이 객체가 누구를 프로토타입으로 들고있느냐.. 조회**

```jsx
const obj = {};
console.log(obj.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null (최상위)
```

- Object.prototype.constructor
  이 객체를 만든 생성자가 뭔지

```jsx
const obj = {};
console.log(obj.constructor === Object); // true

const arr = [];
console.log(arr.constructor === Array); // true
```
