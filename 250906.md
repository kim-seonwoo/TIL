- 일단 JS는 싱글 스레드이므로, 비동기 처리를 어쩔 수 없이 많이 써야함.
  과거에는 콜백을 썼는데 → 콜백 남발하다보니까 코드가 가독성이 많이 떨어짐.

# Promise 상태

- **pending** (대기 중) → 아직 결과를 모름
- **fulfilled** (이행됨) → 작업 성공, `resolve()` 호출
- **rejected** (거부됨) → 작업 실패, `reject()` 호출

```jsx
const promise = new Promise((resolve, reject) => {
  const success = true;

  if (success) {
    resolve("성공!"); // fulfilled 상태
  } else {
    reject("실패..."); // rejected 상태
  }
});

// 그냥 객체

promise
  .then((result) => console.log(result)) // 성공 시 실행
  .catch((error) => console.error(error)) // 실패 시 실행
  .finally(() => console.log("끝!")); // 항상 실행
```

- **then()** → 성공했을 때 실행할 콜백 등록
- **catch()** → 실패했을 때 실행할 콜백 등록
- **finally()** → 성공/실패와 상관없이 마지막에 실행

→ useQuery 처럼 개발자 편의성을 높여주는 문법 설탕 (추상화 이쁘게 해줌)

- Promise는 실제값이 아니라 채워질 수도 있고, 실패할 수도 있는 컨테이너
- fullfill되었을때 then이나 awiat로 꺼낼 수 있음.

[Promise 실전에서 사용해보기 | 토스페이먼츠 개발자센터](https://docs.tosspayments.com/blog/using-promises)

# 비동기에 대하여

- 네이티브 개발을 했을때는 직접 스레드를 제어하며 직접 동기 비동기 방식 실행을 선택할 수 있었음.
- 하지만 js에는 오직 API 설계자가 결정한다.
  개발자가 결정하는 것은 그냥 이 비동기적인 값들을 promise로 처리할지 await로 처리할지 선택하는 것 뿐이다.
- 즉 스위프트의 async와 달리 JS의 async는 문법적 설탕에 고작 불과하다.

```jsx
function fetchUser() {
  return fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then((res) => res.json())
    .then((data) => {
      console.log("✅ 데이터:", data);
      return data;
    })
    .catch((err) => {
      console.error("❌ 에러:", err);
    });
}

fetchUser();
```

```jsx
async function fetchUser() {
  try {
    const res = await fetch("https://jsonplaceholder.typicode.com/todos/1");
    const data = await res.json();
    console.log("✅ 데이터:", data);
    return data;
  } catch (err) {
    console.error("❌ 에러:", err);
  }
}

fetchUser();
```

- 사실은.. async, await를 사용해도, 내부적으로 promise 체인으로 씁니다!

## Async await와 Promise 섞어 쓰기

- promise 고급제어 기능을 이용할 때 많이 사용한다.
- 병렬 처리

```jsx
async function getData() {
  const [user, posts] = await Promise.all([
    fetch("/user/1").then((res) => res.json()),
    fetch("/posts").then((res) => res.json()),
  ]);
  // 동시에 실행하고 다해야 반환
  console.log(user, posts);
}
```

await만 쓰면 순차 실행이라 느려질 수 있는데, Promise.all을 써서 내부적으로 병렬 실행 맥락으로 만든다.

- race (타이머랑 api랑 대결시켜서 먼저 끝나는거 반환할때)

```jsx
async function fetchWithTimeout(url) {
  const timeout = new Promise((_, reject) =>
    setTimeout(() => reject(new Error("Timeout")), 3000)
  );

  return await Promise.race([fetch(url), timeout]);
}
```

- await를 Promise앞에 붙이면 해당 상태가 바뀔때 까지 코드를 기다림.

# React Query와의 조합

- 리액트 쿼리는 Promise 기반 비동기 함수를 관리해주는 거다.

```jsx
const {
  data, // 성공 시 데이터
  error, // 실패 시 에러
  isLoading, // 처음 로딩 중
  isFetching, // 리패치 중 여부
  refetch, // 수동으로 다시 실행
} = useQuery(["user", userId], () => fetchUser(userId));
```

- Promise에 대한 처리를 리액트 쿼리가 isLoading/data/error로 해준다.
  ![스크린샷 2025-09-05 오후 6.07.49.png](attachment:2ccea2a3-2cd8-4397-9ef7-78ab3dcd4f8f:스크린샷_2025-09-05_오후_6.07.49.png)

queryFn을 쓰는데, 여기에 async awiat를 통해서 통신을해서 매핑을 해주면 꿀조합이다.
